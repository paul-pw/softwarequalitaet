\documentclass[12pt, a4paper, ngerman]{article}

% Metadata Setup
\newcommand{\Autor}{Paul Walker und Leon Kampwerth}
\newcommand{\Was}{Ausarbeitung Softwarequalität}
\newcommand{\Kurs}{TINF20IN}
\newcommand{\MatrikelNummer}{3610783, 5722356}
\newcommand{\Studiengang}{Softwarequalität}

\title{Software-Qualitätsbewertung mittels Software Metriken}
\author{\Autor}
\date{22.03.2023}

% SETUP
\usepackage{biblatex} % für bibliografie
\usepackage{hyperref} % für links zum klicken
\usepackage{color}    % für Farben (benötigt für listings)
\usepackage{listings} % code schnipsel
\usepackage[ngerman]{babel} % lokalisierung der Titel (Inhaltsverzeichniss)
\usepackage{bookmark} % bookmarks für das PDF
\usepackage{csquotes} % korrekte quotes
\usepackage[version=3]{acro} % akronyme
\usepackage{geometry} % seitengeometrie (margin etc einstellen)
\usepackage{parskip}  % zeilenabstand bei neuem paragraph statt indentierung
\usepackage{fancyhdr} % header und footer
\usepackage{array}    % für bessere Tabellen
\usepackage{titlesec} % um die Titel anzupassen
\usepackage{plantuml} % PLANTUML_JAR has to be set and --shell-escape
\usepackage{amsfonts} % für \mathbb
\usepackage{placeins} % für \FloatBarrier
\usepackage{nicematrix}
 
\hypersetup{
  pdfauthor={\Autor},
  pdftitle={\Was},
  hidelinks
}

\geometry{
  a4paper,
  left=25mm,
  right=25mm,
  headheight=125mm,
  top=35mm,
  bottom=30mm,
  footskip=15mm
}

% title setup 
% make paragraph have a newline
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% add bibliography
\addbibresource{bibliography.bib}

% header and footer setup
\pagestyle{fancy}
\fancyhf{}
\rhead{\Was}
\lhead{\leftmark}
\lfoot{Autor: \Autor, Kurs: \Kurs}
\rfoot{Seite \thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\fancypagestyle{simple}{
  \fancyhf{}
  \rhead{\Was}
  \lfoot{Autor: \Autor, Kurs: \Kurs}
  \rfoot{Seite \thepage}
}

% acronyms
\acsetup{
  list/display = used,
  pages/display = first
}

%Offizele Akronyme
\DeclareAcronym{iso}{short=ISO, long=International Organization for Standardization}
\DeclareAcronym{cicd}{short=CI/CD, long=Continuous Integration / Continuous Delivery}
\DeclareAcronym{cve}{short=CVE, long=Common Vulnerabilities and Exposures}
\DeclareAcronym{cvss}{short=CVSS, long=Common Vulnerabilitie Scoring System}
\DeclareAcronym{nvd}{short=NVD, long=National Vulnerability Database}
\DeclareAcronym{nist}{short=NIST, long=National Institute of Standards and Technology}

%Eigene Akronyme
\DeclareAcronym{nsrg}{short=NSRG, long=Number of Requirements Gathered}
\DeclareAcronym{srrd}{short=SRRD, long=Security Requirements Recorded Deviations}
\DeclareAcronym{srse}{short=SRSE, long=Security Requirements stage Security Errors}
\DeclareAcronym{sri}{short=SRI, long=Security Requirements Gathering Indicators}
\DeclareAcronym{srs}{short=SRs, long=Security Requirements Statistics}
\DeclareAcronym{dtte}{short=DTTE, long=Design Tools und Test Effectiveness}
\DeclareAcronym{ndse}{short=NDSE, long=Number of Design stage Security Errors}
\DeclareAcronym{psca}{short=PSCA, long=Percent of Secure Coding Aspects}
\DeclareAcronym{pcs}{short=PCS, long=Percent use of Coding Standards}
\DeclareAcronym{nse}{short=NSE, long=Number of Security Errors}
\DeclareAcronym{pe}{short=PE, long=Process Effectiveness}
\DeclareAcronym{str}{short=STR, long=Security Testing Ratio}
\DeclareAcronym{mtcsc}{short=MTCSC, long=Mean Time to Complete Security Changes}
\DeclareAcronym{rva}{short=RVA, long=Rate of Vulnerabilitie Assessments}
\DeclareAcronym{rsc}{short=RSC, long=Ratio of Changes due to security considerations}
\DeclareAcronym{sr}{short=SR, long=Stall Ratio}
\DeclareAcronym{ccp}{short=CCP, long=Coupling Corruption Propagation}
\DeclareAcronym{cer}{short=CER, long=Critical Element Ratio}

\newcommand{\reals}{\ensuremath{\mathbb{R}}}
\newcommand{\natnums}{\ensuremath{\mathbb{N}}}

% code snippet setup
\renewcommand{\lstlistingname}{Code-Auszug}
\renewcommand{\lstlistlistingname}{Liste der Code-Auszüge}

\definecolor{black}{rgb}{0,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{brown}{rgb}{0.69,0.31,0.31}

% python
\lstdefinelanguage{Python}{
  morekeywords={import, def, from, for, in, if, else, return, True, False, catch, return, null, switch, if, in, while, do, else, case, break},
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]""",
  morestring=[b]'
}

\lstdefinestyle{light}{
  % General design
  basicstyle={\footnotesize\ttfamily},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Quellcode design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{green}\bfseries,
  stringstyle=\color{orange}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Quellcode
  alsodigit={.:;},
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
}

\begin{document}
\raggedright % sorgt dafür das alles strikt links ausgerichtet wird (und sorgt für mehr seiten)


% Titlepage
\makeatletter
\begin{titlepage}
  \begin{center}
    \vspace*{1cm}
    {\Huge\scshape \Was}\\[2cm]
    \begin{center}
      \linespread{1}\Huge \@title\\[2cm]
    \end{center}
    {\large \Studiengang}\\
    {\large Duale Hochschule Baden-Württemberg\\ Stuttgart}\\[2cm]
    {\large von}\\
    {\large\bfseries \@author}
    \vfill
  \end{center}
  \begin{tabular}{l@{\hspace{2cm}}l}
    Matrikelnummer: & \MatrikelNummer \\
    Abgabedatum:    & \@date          \\
  \end{tabular}
\end{titlepage}
\makeatother

% Table of content
\tableofcontents
\newpage

\thispagestyle{simple}
\printacronyms[name=Abkürzungsverzeichnis, heading=section*]
\newpage

%%%%%%
% Content here
%%%%%% 

\renewcommand{\abstractname}{Abstract} % dass Abstract auch Abstract heißt und nicht zusammenfassung
\begin{abstract}
Softwarequalität zu messen, kann sich mitunter als schwierig herausstellen.
Diese Arbeit hat das Ziel, einfache Metriken für Qualitätscharakteristika
zu erarbeiten.
Diese Metriken sollen einfach automatisiert messbar sein
und so einen kontinuierlichen Indikator für die Softwarequalität geben,
der auch in \ac{cicd} Prozesse genutzt werden kann.
Der Fokus wird auf die Qualitätscharakteristika
Wartbarkeit und Sicherheit
gesetzt.
\end{abstract}

\section{Einleitung}

Die meisten Menschen arbeiten jeden Tag mit verschiedener Software.
In der Arbeit mit Office-Software oder je nach Beruf spezialisierter
Software für bestimmte Aufgaben und/oder Maschinen.
Zu Hause nutzen viele Menschen Unterhaltungssoftware wie Spiele
oder Videoplattformen.
Software ist heutzutage allgegenwärtig und die meisten Menschen
werden auch schon einmal Software schlechter Qualität genutzt haben.
Das kann durch abruptes Schließen einer Applikation,
unintuitives Design oder langer Ladezeiten
für den Nutzer erkennbar sein.
Es kann recht einfach sein
schlechte Qualitäten in Software zu erkennen,
allerdings lässt sich Softwarequalität so nicht objektiv vergleichen.

Diese Arbeit beschäftigt sich damit Metriken zu finden,
mit denen Software Qualität objektiv gemessen werden kann.
Softwaremetriken werden hauptsächlich
in der Softwareentwicklung genutzt.
Während der Softwareentwicklung können Software Metriken
Fortschritte erkennbar machen und vor Rückschritten warnen.
Software Metriken werden von Entwicklern genutzt,
um die Auswirkung von Änderungen im Quellcode auf zum Beispiel die Softwarequalität
erkennen zu können und reagieren zu können.
Für die Stakeholder, also Kunden oder Investoren,
sind Softwaremetriken interessant, 
um die Arbeit der Entwickler nachvollziehen zu können
und um die Softwareentwicklung in bestimmte Richtungen zu leiten.

\section{Softwarequalität}

Um Softwarequalität messen zu können, muss zuerst festgelegt werden,
was Softwarequalität überhaupt ist.
Viele Aspekte von Softwarequalität sind für den Endnutzer gar nicht
erkennbar oder sind nur dann erkennbar,
wenn dieser Aspekt eine schlechte Qualität hat.

In dieser Arbeit wird die Definition von Softwarequalität
nach \ac{iso} 25010~\cite{ISO25010} verwendet.
In dem \ac{iso} 25010 Standard wird ein Produktqualitätsmodell
für System und Softwarequalität definiert.
Nach diesem Modell wird die Qualität eines Softwaresystems oder Produkts
durch acht Charakteristika definiert.
Diese Charakteristika werden in Abbildung~\ref*{fig:uml:softwarequality} dargestellt.

\begin{figure}
  \centering
  \begin{plantuml}
    @startmindmap
    + ISO 25010 \nQualitätsstandard
    -- Funktionale Eignung
    -- Leistungsfähigkeit
    -- Kompatibilität
    -- Benutzerfreundlichkeit
    ++ Zuverlässigkeit
    ++ Sicherheit
    ++ Wartbarkeit
    ++ Portabilität
    @endmindmap
  \end{plantuml}
  \caption{Softwarequalität nach \ac{iso} 25010~\cite{ISO25010}}
  \label{fig:uml:softwarequality}
\end{figure}

\paragraph{Funktionale Eignung}

Die funktionale Eignung hängt davon ab wie gut funktionale Anforderungen erfüllt werden,
da gemessen wird, zu welchem Grad die vom Nutzer genannten 
und implizierten Anforderungen und Bedürfnisse erfüllt werden~\cite{ISO25010}.

\paragraph{Leistungsfähigkeit}

Die Leistungsfähigkeit beschreibt die Leistung von Software, 
abhängig von den vorhandenen Ressourcen~\cite{ISO25010}.
Dabei meinen Ressourcen sowohl Hardwareressourcen wie Rechenleistung oder Speicher,
als auch Softwareressourcen, wie Konfigurationen oder genutzte Bibliotheken.

\paragraph{Kompatibilität}

Der Grad zu dem ein Softwareprodukt oder System mit anderen Softwareprodukten oder Systemen Informationen
austauschen kann, wird durch die Kompatibilität beschrieben~\cite{ISO25010}.
Außerdem beschreibt die Kompatibilität inwiefern verschiedene Softwaresysteme oder Produkte die gleiche Hardware
oder Softwareumgebung nutzen können, ohne dass dies zu Problemen führt.

\paragraph{Benutzerfreundlichkeit}

Der Grad der Benutzerfreundlichkeit ist nach \ac{iso},
wie effektiv und effizient ein definiertes Ziel von bestimmten Nutzern
mit einem Softwareprodukt oder System erreicht werden kann
und wie zufrieden die Nutzer dabei sind~\cite{ISO25010}.

Teile der Benutzerfreundlichkeit sind von der \ac{iso} 9241-210 Norm
zur Ergonomie von Mensch-System-Interaktionen adaptiert.

\paragraph{Zuverlässigkeit}

Zuverlässigkeit ist die Fähigkeit eines Softwareprodukts oder Systems,
die erforderlichen Funktionen des Produkts oder Systems über einen bestimmten Zeitraum 
und unter bestimmten Bedingungen zu erfüllen~\cite{ISO25010}.
Unzuverlässige Software könnte beispielsweise durch Fehler in der Software
in ihrer Ausführung unterbrochen werden, wodurch die erforderlichen Funktionen
dann nicht mehr in dem bestimmten Zeitraum ausgeführt werden können,
sondern beispielsweise durch einen Neustart der Software länger Zeit benötigen.

\paragraph{Sicherheit}

Die Sicherheit von Software ist der Grad zu dem die Software Informationen und Daten schützt.
Informationen und Daten sind dann geschützt,
wenn andere Personen oder Produkte nur Zugriff auf Daten, 
entsprechend ihrer Berechtigung, haben~\cite{ISO25010}.
Dabei darf sich die Sicherheit der Daten weder beim Transport der Daten,
noch während eines Angriffs auf die Software ändern~\cite{ISO25010}.

Auf die Sicherheit wird in Abschnitt~\ref{sec:sicherheit} weiter eingegangen.

\paragraph{Wartbarkeit}

Der Grad der Wartbarkeit beschreibt die Effektivität und die Effizienz,
mit der ein Softwareprodukt oder System modifiziert werden kann.

Auf die Wartbarkeit wird in Abschnitt~\ref{sec:wartbarkeit} weiter eingegangen.

\paragraph{Portabilität}

Die Portabilität ist ein Maßstab dafür, 
wie effektiv und effizient ein Produkt oder System von einer Hardware-,
Software- oder einer bestimmten Betriebs- oder Nutzungsumgebungen auf andere übertragen werden kann~\cite{ISO25010}.
Portabilität kann auch als die Eigenschaft eines Systems bezeichnet werden,
die es erlaubt, das System einfach auf verschiedene Konfigurationen anpassen zu können~\cite{IEEE24765}.

% ----------

Jedes dieser Charakteristika wird weiter in Subcharakteristika aufgeteilt.
In dieser Arbeit wird der Fokus auf zwei bestimmte Charakteristika gesetzt
und für jedes eine Metrik vorgestellt,
mit der die Qualität der Charakteristik gemessen werden kann.

Eine einzelne Metrik für Softwarequalität zu erstellen ist schwer,
da die Softwarequalität durch so viele Charakteristika beeinflusst wird.
Außerdem würde eine einzelne Metrik für die Softwarequalität nur bedingt nützlich sein.
Es wäre zwar möglich die generelle Qualität einer Software zu quantifizieren,
allerdings lässt sich dann nicht herausfinden, 
in welchen Bereichen Mängel an der Qualität der Software vorliegen.
Es ist sinnvoller einzelne Metriken für die Qualitätscharakteristika
zu erstellen, wie es auch in dieser Arbeit gemacht wird,
da so die Ursache für potenzielle Qualitätsmängel
einfacher gefunden werden kann.

\subsection{Sicherheit}
\label{sec:sicherheit}

Sicherheit beschreibt nach \ac{iso}, wie gut ein Produkt oder ein System die Informationen und Daten schützt.
Ziel ist es sicherzustellen, dass Personen und andere Systeme nur den Grad an Zugriff auf die Daten haben, für den sie berechtigt sind~\cite{ISO25010}.
Dies bezieht sich sowohl auf die Daten, die vom System gespeichert werden, als auch auf die Daten, die vom System übertragen werden~\cite{ISO25010}.
Sicherheit ist ein wichtiges Qualitätsmerkmal für Software und verbessert das Vertrauen der Benutzer und der Stakeholder in die Software~\cite{ISO25010}.
Die Sicherheit ist nach \ac{iso} in weitere Subcharakteristika aufgeteilt.
Diese Subcharakteristika sind in Abbildung~\ref{fig:uml:security} dargestellt.

Ähnlich zur Wartbarkeit ist auch Sicherheit ein sehr wichtiges Qualitätscharakteristika.
Sicherheit wird jedoch nur dann bemerkt wird, wenn sie abwesend ist und 
die Folgen fehlender Sicherheit zeigen sich meist erst einige Zeit nach der Entwicklungsphase.
Daher hat die Sicherheit der Software für viele Entwickler eher eine geringere Priorität 
und die Erfahrung mit dem Themenbereich ist eher gering~\cite{Roshaidie_Liang_Jun_Yew_Fatima-Tuz-Zahra_2020}~\cite{Tahaei_Jenkins_Vaniea_Wolters_2021}.
Trotz einem starken Anstieg an Hackerattacken (insbesondre durch den Einsatz von Ransomware) 
in den letzten Jahren~\cite{BSI_2022}~\cite{Statistik_Cybersecurity_2022} ist Sicherheit weiterhin kein festes Kriterium 
in der Design- und Entwicklungsphase vieler Teams.
Stattdessen wird die Sicherheit meist kurz vor dem Ende der Entwicklung bedacht~\cite{Roshaidie_Liang_Jun_Yew_Fatima-Tuz-Zahra_2020}, 
was die Möglichkeit zum Beheben von architekturellen oder groben Entwicklungsfehlern sehr schwer macht.
Um die Qualität der Sicherheit einer Software zu erhöhen, muss sie schon vor der eigentlichen Entwicklung, 
in der Designphase, mit bedacht werden. Ähnlich zur Wartbarkeit gilt es Regeln und Vorschriften zu definieren, 
die über die Entwicklung hinweg eingehalten werden.

\begin{figure}
  \centering
  \begin{plantuml}
    @startmindmap
    + ISO 25010\nQualitätsstandard
    ++ Sicherheit
    +++_ Vertraulichkeit
    +++_ Integrität
    +++_ Unbestreitbarkeit
    +++_ Verantwortlichkeit
    +++_ Authentizität
    @endmindmap
  \end{plantuml}
  \caption{Sicherheit nach \ac{iso} 25010~\cite{ISO25010}}
  \label{fig:uml:security}
\end{figure}

\subsubsection{Vertraulichkeit}

Vertraulichkeit misst, wie gut das System sicherstellen kann, 
dass ein Zugriff auf Daten nur von berechtigten Benutzern durchgeführt werden kann~\cite{ISO25010}.

\subsubsection{Integrität}

Die Integrität eines Systems beschreibt wie gut es den unautorisierten Zugriff 
oder die Modifikation auf seine Programme oder Daten verhindern kann~\cite{ISO25010}.

\subsubsection{Unbestreitbarkeit}

Der Grad der Unbestreitbarkeit beschreibt, wie gut ein System beweisen kann, 
dass eine Aktion oder ein Ereignis stattgefunden hat.
So soll es einer Entität nicht möglich sein, dies zu bestreiten~\cite{ISO25010}.

Nach der \ac{iso} gibt es zwei Möglichkeiten dies zu erreichen.
Der Ursprungsnachweis ist die erste Möglichkeit. 
Hier erhält das System (der Empfänger) einen Nachweis, wer die Aktion oder das Ereignis ausgelöst hat.
Dies verhindert, dass eine Entität bestreiten kann, dass sie die Aktion oder das Ereignis ausgelöst hat~\cite{ISO7498-2}.
Die zweite Möglichkeit ist der Zustellnachweis.
Hier erhält die Entität, die die Aktion oder das Ereignis ausgelöst hat, 
einen Nachweis, dass das System (der Empfänger) die Aktion oder das Ereignis durchgeführt hat.
Dies verhindert, dass das System bestreiten kann, dass es die Anweisungen erhalten hat~\cite{ISO7498-2}.
Beide Möglichkeiten können einzeln eingesetzt werden oder auch kombiniert werden.

\subsubsection{Verantwortlichkeit}

Verantwortlichkeit gibt an wie gut die Aktionen einer Entität (z.B. Person, System) auf dieses zurückgeführt werden können~\cite{ISO25010}.
Die Verantwortlichkeit kann durch die \emph{Unnachgiebigkeit} und die \emph{Integrität} des Systems beeinflusst werden. 

\subsubsection{Authentizität}
Der Grad der Gewissheit, mit dem die Identität einer Entität (z.B. Person, System) 
bewiesen werden kann wird durch die Authentizität definiert~\cite{ISO25010}.
Das Ziel ist es mit Sicherheit nachweisen zu können, das eine Entität auch die ist, die sie angibt zu sein~\cite{ISO27000}.

\subsection{Wartbarkeit}
\label{sec:wartbarkeit}

Der Grad der Wartbarkeit ist nach \ac{iso},
wie effektiv und effizient das Produkt oder System verändert werden kann~\cite{ISO25010}.
Diese Veränderungen können Korrekturen, Verbesserungen
oder Anpassungen der Software auf Änderungen des Einsatzgebiets
oder auf Änderungen der Anforderungen sein~\cite{ISO25010}.
Die Wartbarkeit bezieht sich auch auf die Installation von Updates~\cite{ISO25010}.
Die Wartbarkeit ist nach \ac{iso} in weitere Subcharakteristika aufgeteilt.
Diese Subcharakteristika sind in Abbildung~\ref{fig:uml:maintainability} dargestellt.

Die Wartbarkeit ist eine der wichtigsten Qualitätscharakteristika für Entwickler.
Viele andere Qualitätscharakteristika wie 
die Benutzerfreundlichkeit oder die Leistungsfähigkeit
bewerten äußere Eigenschaften,
die für den Entwicklungsprozess nicht generell eine Rolle spielen.
So ist die Leistungsfähigkeit von Software 
meist nur in kritischen Bereichen der Software relevant.
Die Benutzerfreundlichkeit von Software spielt 
in der Regel nur in Bereichen mit denen ein Benutzer interagiert eine Rolle.
Dagegen ist die Wartbarkeit von Software
immer dann relevant, 
wenn an und mit bestehendem Quellcode gearbeitet werden muss.
Softwareprodukte oder Systeme,
die eine hohe Wartbarkeit aufweisen,
werden in der Entwicklung und der Wartung einfacher sein
als Softwareprodukte oder Systeme,
die eine geringe Wartbarkeit aufweisen.
Außerdem muss während dem ganzen Entwicklungsprozess
darauf geachtet werden, die potenziell geltenden 
Regeln und Vorschriften zur Wartbarkeit von Software einzuhalten.

\begin{figure}
  \centering
  \begin{plantuml}
    @startmindmap
    + ISO 25010\nQualitätsstandard
    ++ Wartbarkeit
    +++_ Modularität
    +++_ Wiederverwendbarkeit
    +++_ Analysierbarkeit
    +++_ Modifizierbarkeit
    +++_ Testbarkeit
    @endmindmap
  \end{plantuml}
  \caption{Wartbarkeit nach \ac{iso} 25010~\cite{ISO25010}}
  \label{fig:uml:maintainability}
\end{figure}

\subsubsection{Modularität}

Die Modularität wird daran gemessen,
inwieweit das System oder Programm aus einzelnen Teilen besteht
und Änderungen an einem Teil der Software andere Teile nur minimal oder gar nicht beeinflussen~\cite{ISO25010}.
Module sind Softwareattribute, die Software in unabhängige Einzelteile trennen~\cite{IEEE24765}.

\subsubsection{Wiederverwendbarkeit}

Die Wiederverwendbarkeit ist der Grad,
zu dem ein Teil des Systems in mehr als einem System
oder beim Erstellen von weiteren Teilen des Systems verwendet werden kann~\cite{ISO25010}.
Die Wiederverwendung bezieht sich dabei nicht nur auf Software,
sondern auch auf Dokumentation, Software-Design, Applikationstests und weitere Teile des Systems~\cite{IEEE1517}.

\subsubsection{Analysierbarkeit}

Wie effektiv und effizient es möglich ist,
den Einfluss auf ein Produkt oder System abzuschätzen,
wenn ein oder mehrere Teile verändert werden,
ist durch die Analysierbarkeit definiert~\cite{ISO25010}.
Außerdem wie gut der Ursprung von Fehlern
im Produkt oder System diagnostiziert werden kann~\cite{ISO25010}.

\subsubsection{Modifizierbarkeit}

Die Modifizierbarkeit ist ein Maßstab dafür wie effektiv und effizient sich ein Produkt oder System
ändern lässt, ohne dabei Defekte einzuführen oder die Produktqualität zu verschlechtern~\cite{ISO25010}.

Die Modifizierbarkeit kann durch die \emph{Modularität} und die \emph{Analysierbarkeit} beeinflusst werden~\cite{ISO25010}.

\subsubsection{Testbarkeit}

Der Grad der Testbarkeit ist,
wie effektiv und effizient Testkriterien für ein Produkt oder System definiert werden können
und wie effektiv und effizient Tests für das Produkt oder System durchgeführt werden können~\cite{ISO25010}.
Zusätzlich zur Erstellung der Testkriterien und der Durchführung der Tests,
spielt es auch eine Rolle wie gut objektive und messbare Tests erstellt werden können,
die feststellen, ob ein bestimmtes Kriterium erfüllt wurde~\cite{IEEE24765}.

\section{Software Metriken}

Software Metriken sind quantitative Maße,
die zur Bewertung von Softwareprodukten und Softwaresystemen
genutzt werden können.
Diese Metriken können verschiedene Aspekte der Software bewerten.
Hier werden Metriken vorgestellt,
mit denen die Wartbarkeit und die Sicherheit
analysiert werden können.

Software Metriken geben sowohl den Entwicklern
als auch den Stakeholdern der Software
Informationen über Eigenschaften der Software.
Diese Informationen können nützlich sein,
um Risiken frühzeitig zu erkennen,
Verbesserungen und Verschlechterungen zu quantifizieren
und verschiedene Software vergleichen zu können.
Software Metriken können in der Kommunikation
zwischen Entwicklern und Stakeholdern helfen
da sie helfen Eigenschaften der Software zu objektifizierten
und sich so beispielsweise bestimmte Entwicklungstätigkeiten,
wie das Refactoring von Software
besser gegenüber den Stakeholdern rechtfertigen lassen.
Stakeholder können mithilfe von Softwaremetriken
den Entwicklungsprozess besser nachvollziehen
und so besser und gezielter reagieren.
Wenn beispielsweise die Entwicklung eines neuen Features
die Softwarequalität stark verschlechtert,
kann mehr Zeit für die Entwicklung dieses Features
eingeplant werden, damit Qualitätsstandards eingehalten werden können.

Mit Softwaremetriken die,
die Softwarequalität quantifizieren,
können Regeln eingeführt werden,
die bestimmte Mindestanforderungen an die Softwarequalität stellen.
So kann in der Theorie eine konstante objektiv gute Qualität der Software
gewährleistet werden.
Um diese Regeln umzusetzen, ist es hilfreich
die nötigen Metriken automatisch zu generieren
und Änderungen an der Software nur dann zu erlauben,
wenn die Regeln eingehalten werden.

\subsection{Sicherheit}

Sicherheit ist ein Feld, welches in der Informatik sehr weit gefasst ist und in den meisten Themenbereichen eine elementare Rolle spielt.
Daher ist es nicht verwunderlich, dass es schwer ist allgemeine Metriken für das Messen der Sicherheit von Software zu erarbeiten.
Es gibt einige Artikel und Konferenz Papiere, die unterschiedliche Ansätze für das Definieren von Metriken verfolgen und es gibt einige 
Metaanalysen, die die Ergebnisse dieser Arbeiten miteinander vergleichen. 
Zusätzlich dazu wurden Standards definiert, 
welche jedoch weit gefasst sind und eine unpräzise Definition für Sicherheits-Metriken liefern~\cite{MeFlado_Fernández-Medina_Piattini_2010}.

Um einen konkreten Ansatz für die Bewertung der Sicherheit mittels Metriken zu finden, werden 
drei unterschiedliche Ansätze (vereinfacht) vorgestellt~\cite{Jain2014SecurityMA}~\cite{Chowdhury_Chan_Zulkernine_2008}~\cite{Wang_Wang_Guo_Xia_2009} und 
miteinander kombiniert.
Ziel ist es so eine Sammlung an Metriken zu erhalten, 
welche eine Bewertung der Sicherheit einer Software über den Entwicklungsprozess hinweg ermöglichen. 
Abschließend wird bewertet, inwieweit die Sammlung der Metriken alle Subcharakteristika für Sicherheit im \ac{iso} 25010 Qualitätsmodell abdeckt.
Zusätzlich wird die Möglichkeit zur Automatisierung des Bewertungsprozesses betrachtet.

\subsubsection{Security Metrics and Software Development Progression~\cite{Jain2014SecurityMA}}

In ihrem Artikel \emph{Security Metrics and Software Development Progression} beschreiben die Autoren Smirity Jain und Maya Ingle eine Sammlung von Metriken, 
welche die Sicherheit von Software über den gesamten Entwicklungsprozess hinweg messen.
Mit diesen Metriken ist es möglich im Nachhinein die Effektivität der fünf Phasen des Entwicklungsprozesses in Hinblick auf die Sicherheit zu messen.
Im Folgenden wird eine Auswahl der wichtigsten Metriken für die Phasen vorgestellt.

\paragraph{Phase 1: Anforderungsanalyse}

Diese Phase konzentriert sich auf das Sammeln von (Sicherheits-) Anforderungen.
Smirity und Ingle beschreiben hier vier Metriken für die Sicherheit.
\begin{itemize}
  \item \textbf{Number of Security Requirements Gathered \acs{nsrg}}: Anzahl der Sicherheitsanforderungen die in dieser Phase erfasst wurden.
  \item \textbf{Security Requirements Recorded Deviations \acs{srrd}}: Anzahl der Abweichungen von den zuvor definierten Sicherheitsanforderungen in den Anforderungsspezifikationen.
  \item \textbf{Security Requirements stage Security Errors \acs{srse}}: Anzahl der Sicherheitsfehler, welche aus fehlerhaften Sicherheitsanforderungen resultieren.
  \item \textbf{Security Requirements Gathering Indicators \acs{sri}}: Misst den Einfluss der Analysephase auf die Anzahl der Sicherheitslücken. 
\end{itemize}
Für die Auswertung dieser Metriken schlagen die Autoren vor, dass diese Metriken mit der Methode der kleinsten Quadrate zusammengefasst werden.
Dabei werden die Metriken \ac{srrd}, \ac{srse} und \ac{sri} als abhängig definiert, während \ac{nsrg} als unabhängig betrachtet wird.
Das Resultat dieser Rechnung ist die Funktion \alpha, welche die Effektivität dieser Phase in Bezug auf die Sicherheit misst.
Alpha wird mit der Formel~\ref{eq:alpha} berechnet, wobei Y die Summe der Werte der Metriken \ac{srrd}, \ac{srse} und \ac{sri} ist.
\alpha~ist im Intervall von -1 bis 1 aussagekräftig, ein größerer Wert bedeutet eine bessere Effektivität.
Ein Wert von -1 bedeutet, dass Sicherheit in der Phase nicht berücksichtigt wurde 
und ein Wert größer als 1 bedeutet, dass die Effektivität nicht bewertet werden kann.
\begin{equation} \label{eq:alpha}
  \alpha = \frac{ \left( 5,2421 - Y \right) }{ NSRG }
\end{equation}

\paragraph{Phase 2: Design}

In dieser Phase werden die Anforderungen in ein Design überführt. 
Hier ist die Umsetzung von nicht-funktionalen Anforderungen, wie Fehlerbehandlung, Fehlermeldungen und Autorisierung wichtig.
Die Autoren definieren für diese Phase drei Metriken.
\begin{itemize}
  \item \textbf{Security Requirements Statistics \acs{srs}}: Prozentsatz der Sicherheitsanforderungen, welche in der Designphase bedacht wurden.
  \item \textbf{Design Tools und Test Effectiveness \acs{dtte}}: Misst den Anteil von Analysetools (z.B. Threat Analysis und Attack Patterns) und Testing an den sicherheitsrelevanten Designaspekten. 
  \item \textbf{Number of Design stage Security Errors \acs{ndse}}: Misst die Anzahl der Sicherheitsfehler, welche aus dem Software-Design resultieren. 
\end{itemize}
Für die Auswertung dieser Metriken multiplizieren die Autoren die Metriken \ac{dtte} und \ac{ndse}, das Ergebnis ist \beta. 
Da \ac{dtte} den Anteil von Tools und Tests an dem resultierenden Design misst und \ac{ndse} die Fehler welche aus dieser Phase entstehen zählt, 
beschreibt \beta~die Effektivität der Designphase in Bezug auf die Sicherheit.
\beta~wird mit der Formel~\ref{eq:beta} berechnet und ist immer größer gleich 0. 
Der \beta~-Wert sollte zwischen 0 und 1 liegen, ein größerer Wert bedeutet eine schlechtere Effektivität.
Ein \beta~-Wert von 0 impliziert, dass das Testing sehr effektiv ist und es keine Fehler in der Designphase gibt.
\begin{equation} \label{eq:beta}
  \beta = NDSE * DTTE
\end{equation}

\paragraph{Phase 3: Implementierung}

In dieser Phase wird Sicherheit durch Input- und Outputvalidierung und durch die Verwendung von guten Programmierstandards erreicht.
Die Autoren beschreiben hier drei Metriken, um die Sicherheitsanstrengungen der Entwickler zu messen.
\begin{itemize}
  \item \textbf{Percent of Secure Coding Aspects \acs{psca}}: Misst das Verhältnis der sicherheitsrelevanten Coding-Aspekte in der Entwicklungsphase im Vergleich zu den Designaspekten (aus der Designphase).
  \item \textbf{Percent use of Coding Standards \acs{pcs}}: Misst den Anteil an Coding-Standards für sichere Entwicklung, die verwendet wurden. Sie kann als einee Annäherung für \ac{nse} dienen.
  \item \textbf{Number of Security Errors \acs{nse}}: Misst die Anzahl an Programmierfehlern, welche im Programm vorhanden sind oder durch externe Librarys eingebracht wurden.
\end{itemize}
Für die Auswertung verwenden die Autoren wird hier wieder die Methode der kleinsten Quadrate.
Der resultierende Wert \gamma (Gleichung~\ref{eq:gamma}) beschreibt die Effektivität der Implementierungsphase in Bezug auf die Sicherheit.
Ein negativer \gamma Wert deutet auf eine hohe Fehleranzahl hin und ein Wert nahe 0 deutet auf eine gute Effektivität der Phase hin.
\begin{equation} \label{eq:gamma}
  \gamma = \frac{ 8,4022 - NSE }{ PSCA + PCS }
\end{equation}

\paragraph{Phase 4: Testen}

In dieser Phase wird die Software auf Sicherheitslücken getestet.
Die wichtigsten Metriken sind folgende.
\begin{itemize}
  \item \textbf{Process Effectiveness \acs{pe}}: Beschreibt das Verhältnis zwischen der Anzahl der entdeckten Sicherheitslücken und der Anzahl der Module, die Sicherheitstests unterzogen wurden.
  \item \textbf{Security Testing Ratio \acs{str}}: Misst den Anteil der Module, die Sicherheitstests unterzogen wurden.
\end{itemize}

\paragraph{Phase 5: Betrieb und Wartung}

In dieser Phase werden Risikobewertungen und Sicherheitsanalysen durchgeführt, um bei Patches eingebrachte Sicherheitsfehler zu finden.
Außerdem findet hier das Logging, Monitoring und die Analyse von Sicherheitsereignissen statt.
Die Autoren beschreiben hier drei Metriken.
\begin{itemize}
  \item \textbf{Mean Time to Complete Security Changes \acs{mtcsc}}: Schätzt die durchschnittliche Zeit, die es braucht um einen Sicherheitsfehler zu beheben. 
  \item \textbf{Rate of Vulnerability Assessments \acs{rva}}: Misst die Anzahl der Sicherheitsanalysen pro Quartal.
  \item \textbf{Ratio of Changes due to security considerations \acs{rsc}}: Misst den Anteil der Änderungen am System aufgrund neuer Sicherheitsanforderungen im Vergleich zur Gesamtheit der Systemänderungen.
\end{itemize}

\subsubsection{Security Metrics for Source Code Structures~\cite{Chowdhury_Chan_Zulkernine_2008}}

In dem Paper \emph{Security Metrics for Source Code Structures} werden drei Metriken vorgestellt, 
welche das Messen der Sicherheit auf Quellcode-Ebene ermöglichen.
Ziel ist es eine Bewertung der Code-Qualität durchzuführen und 
festzustellen, ob Fehler oder Unreinheiten vorhanden sind, die ein Angreifer ausnutzen könnte.
Die Metriken sind folgende.

\paragraph{Stall Ratio \acs{sr}}

Die Stall Ratio misst, welcher Anteil des Programmcodes nicht benötigt wird, um dessen definiertes Ziel zu erreichen.
Gerade in einer Schleife verzögern sogenannte Stall Statements die Ausführung des Programms und können somit einen Angriff erleichtern.
Die Stall Ratio wird mit der Formel~\ref{eq:sr} berechnet.
\begin{equation} \label{eq:sr}
  \text{Stall Ratio} = \frac{ \text{Nicht-zielführende Zeilen in einer Schleife} }{ \text{Gesamtanzahl der Zeilen in der Schleife} }
\end{equation}

% Villeicht ein Beispiel?
Nicht alle Stall Statements sind schlecht, gerade das Schreiben von Logs, Fehlermeldungen etc. sind notwendig.
Dennoch sollten auch diese Stall Statements nicht allzu oft vorkommen.
Angreifer nutzen häufig Denial of Service Angriffe, um die Verfügbarkeit von Systemen zu beeinträchtigen.
Eine hohe Anzahl an Stall Statements kann die Auswirkungen eines solchen Angriffs verstärken.

\paragraph{Coupling Corruption Propagation \acs{ccp}}

Kopplung von Methoden meint, dass zwei oder mehr Methoden voneinander abhängig sind.
Ein Beispiel für eine Kopplung ist die Verwendung von globalen Variablen oder 
die Verwendung von Methoden aus anderen Klassen.
Die Effekte einer Kopplung können sich schnell auf mehrere Methoden tiefer in der Kette auswirken.
Angreifer können so Werte in einer Methode generieren, die dann Fehler in einer anderen Methode verursachen.
Coupling Corruption Propagation \ac{ccp} bestimmt die Anzahl der Methoden, 
die durch einen Fehler in einer Methode beeinflusst werden können.
Hierfür wird die Anzahl der Kindmethoden gezählt, die mit einem Parameter aufgerufen werden, 
welcher auf einem Parameter der Originalmethode beruht.
Mit einer geringeren Kopplung ist auch der \ac{ccp} geringer.
Kopplung ist häufig unumgänglich, Methoden mit einer hohen Kopplung sollten daher ausführlich getestet werden.
% Villeicht beispiel?

\paragraph{Critical Element Ratio \acs{cer}}

Bei objektorientierten Programmiersprachen gibt es Objekte, 
die während der Laufzeit des Programms initialisiert werden. 
Für diesen Prozess ist es aber nicht unbedingt nötig alle Aspekte eines Objekts zu initialisieren.
Andere Aspekte des Objekts sind elementar für das Funktionieren des Programms, 
wenn sie verändert werden kann das Programm instabil werden und somit ein Sicherheitsrisiko darstellen.
Es gilt, je höher die Anzahl dieser kritischen Elemente in einer Klasse, desto höher ist das Sicherheitsrisiko.
Um dieses Risiko zu messen, wird der Anteil der kritischen Datenelemente in einem Objekt berechnet \ac{cer}.
Wichtig ist hierbei, dass nur Datenelemente berücksichtigt werden, 
die während der Laufzeit des Programms durch einen Benutzer verändert werden können.
Die Formel für die Berechnung des \ac{cer} ist in der Formel~\ref{eq:cer} angegeben.
\begin{equation} \label{eq:cer}
  \text{Critical Element Ratio} = \frac{ \text{Kritische Datenelemente in einem Objekt} }{ \text{Gesamtanzahl der Elemente in einem Objekt} }
\end{equation}
% Villeicht beispiel?

\subsubsection{Security Metrics for Software Systems~\cite{Wang_Wang_Guo_Xia_2009}}

In dem Paper \emph{Security Metrics for Software Systems} nutzen die Autoren \ac{cve}, 
um Schwachstellen in einem Softwaresystem zu identifizieren. 
Die Menge an \ac{cve}s, für die ein System anfällig ist, dient als Indikator für ein potenziell höheres Sicherheitsrisiko.
Dabei wird auch die Schwere der \ac{cve}s nach \ac{cvss}, sowie die Wahrscheinlichkeit der Ausnutzung berücksichtigt.

\paragraph{Common Vulnerabilitie Scoring System \acs{cvss}}

Das \ac{cvss} ist ein System zur Bewertung der Schwere und 
des damit einhergehenden Risikos einzelner Sicherheitslücken auf Computer-Umgbebungen.
CVSS wurde von der US-amerikanischen Organisation \ac{nist} entwickelt. 
Die Bewertung ist in  3 Kategorien unterteilt, die jeweils eine eigene Skala haben.
Die Basismetrik misst die grundlegenden Eigenschaften einer Schwachstelle und ist zeit- und umgebungsunabhängig.
Die zeitliche Metrik beschreibt die Schwere einer Schwachstelle in Abhängigkeit von der Zeit.
Die Umgebungs-Metrik beschreibt die Schwere einer Schwachstelle in Abhängigkeit der Umgebung des Benutzers.
Für die Bewertung werden mehrere Fragen zu den Metriken mit einem Wert zwischen 0 und 10 beantwortet.
Der durchschnitt der Werte aller Fragen einer Metrik ergibt den Wert für diese Metrik (0 - 10).
Für die zeitliche Bewertung wird die Bewertung der Basis- und der Zeitmetrik addiert.
Für die Umgebungs-Bewertung werden alle drei Metriken miteinander verrechnet.

\paragraph{Common Vulnerabilities and Exposures \acs{cve}}

Die Veröffentlichung von Sicherheitslücken findet in der Regel über die \ac{cve}-Datenbank statt, 
hier werden diese Lücken in einem einheitlichen Format veröffentlicht.
RedHat schreibt dazu auf ihrer Webseite \cite{Redhat_CVE}: 
\begin{quote}
  \textit{
    CVE, kurz für Common Vulnerabilities and Exposures (Häufige Schwachstellen und Risiken), ist eine Liste mit öffentlichen Sicherheitsschwachstellen in Computersystemen. Mit CVE ist eine bestimmte Schwachstelle gemeint, der eine CVE-Nummer zugewiesen ist.
    In Sicherheitshinweisen von Anbietern und Forschenden wird fast immer mindestens eine CVE-Nummer erwähnt. Mithilfe von CVEs können IT-Fachleute solche Schwachstellen leichter priorisieren und beheben, um Computersysteme sicherer zu machen.
  } 
\end{quote}
Webseiten wie die \ac{nvd} bieten eine Schnittstelle zur \ac{cve}-Datenbank an und 
verknüpfen diese mit den entsprechenden Produkten und der \ac{cvss} Bewertung.

\paragraph{Software Sicherheits Metrik}

Für das Erstellen der Metrik haben die Forscher nun vorgeschlagen, 
die wichtigsten Schwachstellen einer Software zu identifizieren und \ac{cve} Einträge zu diesen zu finden.
Für diese einzelnen Schwachstellen wird dann die durchschnittliche \ac{cvss} Bewertung aller \ac{cve}s berechnet.
So kann die Schwere der Schwachstellen gemessen werden.
Um das Risiko \(R\) für ein Ausnutzen dieser Schwachstelle in die Bewertung einfließen zu lassen, 
schlagen die Forscher vor, die Anzahl der \ac{cve}s einer Schwachstelle \(K\) mit dem Zeitraum (in Monaten) in dem die Schwachstelle in dem System existierte \(M\) zu verrechnen (siehe Gleichung~\ref{eq:cve_risk}).
\begin{equation} \label{eq:cve_risk}
  R = \frac{ K }{ M }
\end{equation}
Abschließend wird die durchschnittliche \ac{cvss} Bewertung aller Schwachstellen mit dem Missbrauchsrisiko verrechnet (siehe Gleichung~\ref{eq:cve_risk2}).
Mit dieser Formel lässt sich die Sicherheit der Software \(s\) berechnen.
\begin{equation} \label{eq:cve_risk2}
  SM \left( s \right) = \sum_{ n=1 }^{ m }{ \left[ \left( \frac{ R_{ n } }{ \sum_{ i=1 }^{ m }{ R_{ i } } } \right) \times W_{ n } \right] }
\end{equation}

\paragraph{Verbesserungsansätze}
In diesem Paper wenden die Autoren viel Zeit auf, um Schwachstellen in dem System zu identifizieren und zu kategorisieren.
Dieser händische Prozess lässt sich durch die Verwendung der National Vulnerability Database deutlich vereinfachen.
Hier werden Softwaresysteme und Packete aufgelistet, welche Schwachstellen aufweisen und 
es wird angemerkt, ab welcher Version diese Schwachstelle behoben wurde.
Zur Vereinfachung dieses Prozesses kann es hilfreich sein, einen Scanner zu verwenden, 
welcher die verwendete Software und Pakete identifiziert und 
die Schwachstellen in der \ac{nvd} Datenbank mit den identifizierten Paketen vergleicht.
Die gefundenen Schwachstellen können zusammen mit dem Zeitraum, 
in dem der Scanner diese im System gefunden hat, verwendet werden, um die Metrik zu berechnen.
So kann eine höhere Automatisierung erreicht werden.

\subsubsection{Kombination der Ansätze und Bewertung der Metriken}

\begin{center}
  \begin{table}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{NiceTabular}{|l|c|c|c|c|c|c|}
      \hline
      & \rotate \alpha-Wert
      & \rotate \beta-Wert
      & \rotate \gamma-Wert
      & \rotate PE und STR
      & \rotate MTCSC
      & \rotate RSC\\\hline
      Vertraulichkeit         &x&x& &x&x&x\\\hline
      Integrität              &x& &x&x&x&x\\\hline
      Unbestreitbarkeit       &x& &x& & & \\\hline
      Verantwortlichkeit      &x&x&x& & & \\\hline
      Authentizität           &x&x& & & & \\\hline
    \end{NiceTabular}
    \caption{Zugehörigkeit der Metriken zu den Sicherheit-Subcharakteristika}
    \label{table:security_metrics_1}
  \end{table}
\end{center}

\begin{center}
  \begin{table}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{NiceTabular}{|l|c|c|c|c|}
      \hline
      & \rotate SR
      & \rotate CCP
      & \rotate CER
      & \rotate CVE-Metrik\\\hline
      Vertraulichkeit         & & & &x\\\hline
      Integrität              &x&x&x&x\\\hline
      Verantwortlichkeit      & & & &x\\\hline
      Modifizierbarkeit       & & & &x\\\hline
      Authentizität           & & & &x\\\hline
    \end{NiceTabular}
    \caption{Zugehörigkeit der Metriken zu den Sicherheit-Subcharakteristika}
    \label{table:security_metrics_2}
  \end{table}
\end{center}

In Tabelle \ref{table:security_metrics_1} und \ref{table:security_metrics_2} ist aufgeschlüsselt welche Charakteristika der \ac{iso} 25010 durch die Metriken abgedeckt werden.
Tabelle \ref{table:security_metrics_1} gibt einen Überblick über die Abdeckung der Metriken des ersten Artikels~\cite{Jain2014SecurityMA}.
Da in der Analysephase die Grundlagen für alle weiteren Phasen der Softwareentwicklung gelegt werden, 
deckt der \alpha~-Wert alle Charakteristika der \ac{iso} 25010 ab.
Der \beta~-Wert gibt eine Aussage über die Effektivität der Designphase, 
der Fokus liegt daher auf der Identifikation, Autorisierung und weiteren nicht-funktionalen Anforderungen.
Der \gamma~-Wert gibt eine Aussage über die Effektivität der Implementierungsphase, daher ist er wichtig für die Integrität, Unbestreitbarkeit und Verantwortlichkeit.
Process Effectiveness und Security Testing Ratio ermöglichen die Bewertung der Testphase und 
die Effektivität, darin Fehler und Sicherheitslücken festzustellen. 
Daher liegt der Fokus hier auf Vertraulichkeit und Integrität.
Dasselbe gilt auch für die Metriken der Betriebs- und Wartungsphase.

Tabelle \ref{table:security_metrics_2} gibt einen Überblick über die Abdeckung der Metriken der anderen beiden Paper~\cite{Chowdhury_Chan_Zulkernine_2008}~\cite{Wang_Wang_Guo_Xia_2009}.
Da das erste Paper sich auf die Sicherheit auf der Quellcode-Ebenen konzentriert, deckten die Metriken nur das Charakteristika der Integrität ab.
Die Tiefe der Analyse macht diese Metriken sehr effektiv für die Analyse des Quellcodes.
Das zweite Paper fokussiert sich auf die Bewertung von Softwaresystemen auf Basis der Anfälligkeit für bekannte Schwachstellen.
Da die Art der Schwachstellen vielseitig ist, können so abhängig von den betrachteten Systemen und Komponenten auch alle Charakteristika der \ac{iso} 25010 abgedeckt werden.

\subsection{Wartbarkeit}

Viele Charakteristika der Wartbarkeit lassen sich über die Dauer oder Effizienz von Wartungsaufgaben messen.
Es kann beispielsweise die Zeit gemessen werden, die benötigt wird,
um eine Änderung an der Software durchzuführen,
um damit die Modifizierbarkeit zu charakterisieren~\cite{maintainability_metrics}.%II C 

Diese Metriken lassen sich allerdings nur bei konkreten Wartungsaufgaben messen.
Das ist problematisch, da so die Qualität der Software nur durch großen Aufwand bestimmt werden kann.
Ziel ist es daher eine Metrik zu finden, mit der sich die Wartbarkeit ohne großen Aufwand bestimmen lässt.
Das Paper \emph{A Practical Model for Measuring Maintainability} von Ilja Heitlager, Tobias Kuipers und Joost Visser~\cite{maintainability_metrics}
stellt eine Möglichkeit dar, die Wartbarkeit ohne großen Aufwand zu messen.
Allerdings basiert dieses Paper auf dem älteren \ac{iso} 9126 Qualitätsmodell~\cite{maintainability_metrics,ISO9126}.
In dieser Arbeit wird die Metrik, die in~\cite{maintainability_metrics} daher erweitert
und auf das neuere \ac{iso} 25010 Qualitätsmodell angepasst.

Für diese Metrik werden einige einfache Kennzahlen der Software kombiniert,
um Kennwerte für die jeweiligen Subcharakteristika der Wartbarkeit zu berechnen.
Diese Kennwerte können dann verwendet werden, um einen Gesamtwert
für die Wartbarkeit der Software zu bekommen.

\paragraph{Quellcodevolumen}

Die Zahl der effektiven Quellcodezeilen im gesamten Bereich, der analysiert werden soll.
Je geringer das Quellcodevolumen ist,
desto einfacher ist es eine Übersicht über den Bereich zu bekommen,
der analysiert werden soll.
Also ist niedriger besser.

\paragraph{Komplexität der Einheiten}

Die zyklomatische Komplexität einer Einheit sagt aus wie Komplex eine Einheit ist
und damit auch, wie komplex Wartungsaufgaben sein können.
Eine Einheit ist dabei das kleinste ausführbare Stück Code~\cite{maintainability_metrics}.
Je nach Programmiersprache kann eine Einheit eine Funktion, eine Klasse oder aber das gesamte Programm sein~\cite{maintainability_metrics}.
Eine geringere Komplexität spricht für besser wartbare Software.
Die zyklomatische Komplexität von Software kann mit Tools
wie \emph{scc}~\cite{scc} automatisiert gemessen werden.
Hier ist also niedriger besser.

\paragraph{Quellcode Duplikation}

Quellcode Duplikation ist definiert durch die Anzahl Quellcode Zeilen,
die eins zu eins an verschiedenen Stellen zu finden sind.
Duplikation spricht für Probleme in der Software.
Also ist für eine höhere Qualität der Software eine niedrige Duplikation besser.

\paragraph{Einheitengröße}

Eine geringe Einheitengröße sorgt für eine höhere Softwarequalität,
da kleinere Einheiten einfacher zu warten sind.

\paragraph{Unit-Testabdeckung}

Die Testabdeckung durch Unit-Tests wird häufig verwendet,
um Aussagen über die Softwarequalität zu machen.
Hier wird diese Metrik auch verwendet.
Allgemein gilt, je mehr Unit-Tests vorhanden sind, desto besser.

\paragraph{Modulanzahl}

Die Modulanzahl gibt Aussage über die Modularisierung von Software.
Je höher die Modulanzahl, desto modularisierter ist die Software.
Hier ist also höher besser.

\paragraph{Wiederverwendung von Einheiten}

Die Wiederverwendung von Einheiten sagt aus,
wie oft eine Einheit an anderer Stelle im Quellcode wiederverwendet wird.
Das kann gemessen werde, indem gezählt wird wie oft Klassen genutzt werden
oder wie oft Funktionen aufgerufen werden.
Hier gilt, höher ist besser.

Diese Kennzahlen werden wie folgt kombiniert,
um Metriken für die Subcharakteristika zu erhalten.

\paragraph{Modularität}

Eine einfache Metrik für die Modularität ist die Modulanzahl
in dem betrachteten Teil der Software.
Nachteil dieser Metrik ist, dass sie nicht aussagt,
inwieweit Änderungen an einem Modul die anderen Module beeinflussen.
Nach ISO 25010 sollen Änderungen an einem Modul
die anderen Module möglichst wenig beeinflussen~\cite{ISO25010}.

Eine andere Metrik ist die Einheitengröße.
Diese gibt auch eine gewisse objektive Aussage über die Modularität.
Für eine hohe Modularität ist eine geringe Kopplung und
hohe Kohäsion, also hohe Zusammengehörigkeit, innerhalb der Einheiten nötig, um zu gewährleisten,
dass Änderungen an einem Modul die anderen Module minimal oder gar nicht beeinflussen.
Viele kleine Einheiten sprechen für eine hohe Kohäsion,
da in einer kleinen Einheit nur wenig Funktionalität,
die dann aber stark zusammenhängt, implementiert werden kann.

Sowohl die Modulanzahl als auch die Einheitengröße werden
für die Modularität-Metrik verwendet.

\paragraph{Wiederverwendbarkeit}

Die Wiederverwendbarkeit lässt sich nicht direkt messen,
allerdings kann gemessen werden wie oft Softwarekomponenten
tatsächlich wiederverwendet werden, also die Wiederverwendung.
Bei hoher Wiederverwendung muss auch die Wiederverwendbarkeit hoch sein.
Eine niedrige Wiederverwendung ist ein starker Indikator für niedrige Wiederverwendbarkeit.

Eine weitere Metrik für die Wiederverwendung ist die Code-Duplikation und die Einheitengröße.
Wenn hohe Code-Duplikation vorhanden ist, ist die Wiederverwendung in der Regel gering,
da duplizierter Code oft wiederverwendbarer implementiert werden kann.
Bei geringer Code-Duplikation kann davon ausgegangen werden,
dass eine hohe Wiederverwendung des Codes gegeben ist.
Für eine hohe Wiederverwendbarkeit ist es wichtig,
dass Einheiten nur wenige Aufgaben haben.
Eine geringe Einheitengröße deutet daher auf eine höhere Wiederverwendbarkeit.

\paragraph{Analysierbarkeit}

Nach~\cite{maintainability_metrics} werden Code-Volumen, Code-Duplikation, Einheitengröße
und Unit-Testabdeckung verwendet, um die Analysierbarkeit zu quantifizieren.
Geringes Code-Volumen und geringe Einheitengröße hilft
schnell einen Überblick über den Quellcode zu bekommen,
da weniger Quellcode gelesen werden muss, um die Funktion der Software zu verstehen
und die Auswirkungen von Änderungen abzuschätzen.
Unit-Tests helfen die Funktionsweise des Quellcodes zu verstehen.
Außerdem helfen Unit-Tests dabei Fehler in der Software schneller finden zu können
und den Ursprung dieser Fehler zu finden und zu analysieren.
Eine hohe Quellcode-Duplikation erschwert hingegen das Verständnis.

\paragraph{Modifizierbarkeit}

In~\cite{maintainability_metrics} wird die Komplexität der Einheiten und die Code-Duplikation
als Metrik für die Modifizierbarkeit genannt.
Code-Duplikation verringert die Modifizierbarkeit, da an Stellen mit dupliziertem Code
alle Teile des duplizierten Codes gleichermaßen geändert werden müssen.
Das erhöht den Modifikationsaufwand stark und erhöht die Chance,
dass bei Modifikationen vergessen wird Teile des duplizierten Codes zu ändern und so Fehler im Programm entstehen.
Eine hohe Komplexität der Einheiten sorgt dafür,
dass es schwieriger ist diese Einheiten zu modifizieren, ohne Fehler in der Software zu erzeugen.

\paragraph{Testbarkeit}

Die Testbarkeit von Software hängt nach~\cite{maintainability_metrics} unter anderem von der Komplexität der Einheiten,
der Einheitengröße und der Zahl der Unit-Testabdeckung ab.
Eine hohe Unit-Testabdeckung ist ein Indikator für gute Testbarkeit,
denn das bedeutet, dass die Software im allgemeinen testbar ist.
Kleine Einheitengröße sorgt auch für eine bessere Testbarkeit,
da es einfacher ist für kleine Einheiten, die weniger Aufgaben haben, Testfälle zu spezifizieren.
Die Komplexität der Einheiten spielt auch eine Rolle,
da für komplexe Einheiten voraussichtlich mehr und komplexere Testfälle spezifiziert werden müssen.

\begin{center}
  \begin{table}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{NiceTabular}{|l|c|c|c|c|c|c|c|}
      \hline
      & \rotate Quellcodevolumen
      & \rotate Komplexität der Einheiten
      & \rotate Quellcode Duplikation
      & \rotate Einheitengröße
      & \rotate Unit-Testabdeckung
      & \rotate Modulanzahl
      & \rotate Wiederverwendung von Einheiten \\\hline
      Modularität           & & & &x& &x& \\\hline
      Wiederverwendbarkeit  & & &x&x& & &x\\\hline
      Analysierbarkeit      &x& &x&x&x& & \\\hline
      Modifizierbarkeit     & &x&x& & & & \\\hline
      Testbarkeit           & &x& &x&x& & \\\hline
    \end{NiceTabular}
    \caption{Zugehörigkeit der Kennzahlen zu den Wartbarkeit-Subcharakteristika}
    \label{table:maintainability_metrics}
  \end{table}
\end{center}

In Tabelle~\ref{table:maintainability_metrics} wird die Zugehörigkeit
der zuvor vorgestellten Quellcode Kennzahlen zu den
Wartbarkeit-Subcharakteristika dargestellt.
Diese Tabelle erweitert die in~\cite{maintainability_metrics}
vorgestellte Tabelle um die Änderungen, die der neuere \ac{iso} 25010 Qualitätsstandard
gegenüber dem alten \ac{iso} 9126 Standard bringt.
Damit kann nun Software verglichen werden und Qualitätsänderungen
durch Änderungen an der Software gemessen werden.
Im Gegensatz zu~\cite{maintainability_metrics}
wird hier keine konkrete Kennzahl für die Wartbarkeit vorgestellt.
Vielmehr können mit dieser Metrik Softwarestände und Softwaresysteme relativ zueinander verglichen werden.
Dafür werden die relativen Unterschiede in den einzelnen Metriken eins zu eins nach der Tabelle verrechnet,
um einen Wert für die jeweilige Subcharakterstik der Wartbarkeit zu erhalten.
Um daraus einen Wert für die Wartbarkeit zu erhalten,
werden die Werte der Subcharakteristika eins zu eins verrechnet.

Um diese Metrik zu verbessern,
kann die Verrechnung der einzelnen Quellcode-Kennzahlen
gewichtet werden.
Diese Entscheidung kann je nach Anwendung der Metrik getroffen werden.

Es ist denkbar diese Metrik automatisch durch
Softwaretools zu generieren.
Das ermöglicht es diese Metrik als Auswertung von Software
in ein \ac{cicd} System zu integrieren.
Damit können Änderungen an der Software ausgewertet werden
und gewarnt werden, wenn die Wartbarkeit durch Änderungen an der Software verschlechtert wird.
Im extremsten Fall kann eine Änderung auch abgelehnt werden, wenn die Wartbarkeit verschlechtert wird.

\section{Ausblick}

Die hier vorgestellte Metrik zur Wartbarkeit macht es zwar einfach
die Wartbarkeit von Softwareprodukten und Softwaresystemen
zu messen, allerdings hat diese Metrik auch einige Nachteile.
So kann diese Metrik keine direkte Aussage über die Dauer 
von Wartungsaufgaben an der Software machen.
Außerdem wurde nicht verglichen wie sich diese Metrik 
im Vergleich mit anderen Wartbarkeit-Metriken verhält.
Es ist denkbar, dass die hier vorgestellte Metrik
völlig andere Werte als andere Wartbarkeit-Metriken liefert.
In einer weiteren Arbeit könnte darauf eingegangen werden
und die hier vorgestellte Wartbarkeit-Metrik
mit andere Wartbarkeit-Metriken verglichen werden,
um festzustellen, inwieweit sich diese unterscheiden.

Außerdem bietet die hier vorgestellte Wartbarkeit-Metrik 
die Möglichkeit Gewichte zu setzen, 
um die Metrik weiter zu verbessern und anzupassen.
In einer weiteren Arbeit könnte diese Metrik durch
die Gewichtungen an andere Wartbarkeit-Metriken angepasst werden.

Der Bereich Sicherheit ist sehr umfangreich und es gibt viele verschiedene Ansätze und Metriken.
Zusammengenommen bieten die behandelten Metriken eine gute Abdeckung der Charakteristika der \ac{iso} 25010 und 
ermöglichen die Bewertung sowohl auf der tiefen Quellcode-Ebene, als auch mit Hinblick auf das System als Ganzes.
Zusätzlich wird auch der Prozess der Softwareentwicklung berücksichtigt, 
der eine elementare Rolle in der Entwicklung von guter sicherer Software spielt. 
Die automatisierte Umsetzung aller Ansätze ist schwer möglich, 
da gerade im Softwareentwicklungsprozess viele verschiedene Personen und Teams involviert sind.
Dies macht die Analyse sehr komplex.
Dennoch lassen sich die Metriken zur Sicherheit auf Quellcode-Ebene und auf CVE-Basis sehr gut automatisieren.
Eine Kombination der beiden Ansätze ist ebenfalls möglich, indem man den Sourcecode und die Abhängigkeiten automatisch scannt. 

In einer weiteren Arbeit ist es außerdem denkbar weitere Metriken zu finden,
mit denen die übrigen Qualitätscharakteristika 
einfach quantifiziert werden können.


\newpage
\printbibliography

\end{document}
