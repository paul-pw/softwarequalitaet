\documentclass[12pt, a4paper, ngerman]{article}

% Metadata Setup
\newcommand{\Autor}{Paul Walker und Leon Kampwerth}
\newcommand{\Was}{Ausarbeitung Softwarequalität}
\newcommand{\Kurs}{TINF20IN}
\newcommand{\MatrikelNummer}{3610783, 5722356}
\newcommand{\Studiengang}{Softwarequalität}

\title{Software-Qualitätsbewertung mittels Software Metriken}
\author{\Autor}
\date{22.03.2023}

% SETUP
\usepackage{biblatex} % für bibliografie
\usepackage{hyperref} % für links zum klicken
\usepackage{color}    % für Farben (benötigt für listings)
\usepackage{listings} % code schnipsel
\usepackage[ngerman]{babel} % lokalisierung der Titel (Inhaltsverzeichniss)
\usepackage{bookmark} % bookmarks für das PDF
\usepackage{csquotes} % korrekte quotes
\usepackage[version=3]{acro} % akronyme
\usepackage{geometry} % seitengeometrie (margin etc einstellen)
\usepackage{parskip}  % zeilenabstand bei neuem paragraph statt indentierung
\usepackage{fancyhdr} % header und footer
\usepackage{array}    % für bessere Tabellen
\usepackage{titlesec} % um die Titel anzupassen
\usepackage{plantuml} % PLANTUML_JAR has to be set and --shell-escape
\usepackage{amsfonts} % für \mathbb
\usepackage{placeins} % für \FloatBarrier
\usepackage{nicematrix}
 
\hypersetup{
  pdfauthor={\Autor},
  pdftitle={\Was},
  hidelinks
}

\geometry{
  a4paper,
  left=25mm,
  right=25mm,
  headheight=125mm,
  top=35mm,
  bottom=30mm,
  footskip=15mm
}

% title setup 
% make paragraph have a newline
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% add bibliography
\addbibresource{bibliography.bib}

% header and footer setup
\pagestyle{fancy}
\fancyhf{}
\rhead{\Was}
\lhead{\leftmark}
\lfoot{Autor: \Autor, Kurs: \Kurs}
\rfoot{Seite \thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\fancypagestyle{simple}{
  \fancyhf{}
  \rhead{\Was}
  \lfoot{Autor: \Autor, Kurs: \Kurs}
  \rfoot{Seite \thepage}
}

% acronyms
\acsetup{
  list/display = used,
  pages/display = first
}

\DeclareAcronym{iso}{short=ISO, long=International Organization for Standardization}
\DeclareAcronym{cicd}{short=CI/CD, long=Continuous Integration / Continuous Delivery}


\newcommand{\reals}{\ensuremath{\mathbb{R}}}
\newcommand{\natnums}{\ensuremath{\mathbb{N}}}

% code snippet setup
\renewcommand{\lstlistingname}{Code-Auszug}
\renewcommand{\lstlistlistingname}{Liste der Code-Auszüge}

\definecolor{black}{rgb}{0,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{brown}{rgb}{0.69,0.31,0.31}

% python
\lstdefinelanguage{Python}{
  morekeywords={import, def, from, for, in, if, else, return, True, False, catch, return, null, switch, if, in, while, do, else, case, break},
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]""",
  morestring=[b]'
}

\lstdefinestyle{light}{
  % General design
  basicstyle={\footnotesize\ttfamily},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Quellcode design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{green}\bfseries,
  stringstyle=\color{orange}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Quellcode
  alsodigit={.:;},
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
}

\begin{document}
\raggedright % sorgt dafür das alles strikt links ausgerichtet wird (und sorgt für mehr seiten)


% Titlepage
\makeatletter
\begin{titlepage}
  \begin{center}
    \vspace*{1cm}
    {\Huge\scshape \Was}\\[2cm]
    \begin{center}
      \linespread{1}\Huge \@title\\[2cm]
    \end{center}
    {\large \Studiengang}\\
    {\large Duale Hochschule Baden-Württemberg\\ Stuttgart}\\[2cm]
    {\large von}\\
    {\large\bfseries \@author}
    \vfill
  \end{center}
  \begin{tabular}{l@{\hspace{2cm}}l}
    Matrikelnummer: & \MatrikelNummer \\
    Abgabedatum:    & \@date          \\
  \end{tabular}
\end{titlepage}
\makeatother

% Table of content
\tableofcontents
\newpage

\thispagestyle{simple}
\printacronyms[name=Abkürzungsverzeichnis, heading=section*]
\newpage

%%%%%%
% Content here
%%%%%% 

\renewcommand{\abstractname}{Abstract} % dass Abstract auch Abstract heißt und nicht zusammenfassung
\begin{abstract}
Softwarequalität zu messen kann sich mitunter als schwierig herausstellen.
Diese Arbeit hat das Ziel einfache Metriken für Qualitätscharakteristika
zu erarbeiten.
Diese Metriken sollen einfach automatisiert messbar sein
und so einen kontinuierlichen Indikator für die Softwarequalität geben,
der auch in \ac{cicd} Prozesse genutzt werden kann.
Der Fokus wird auf die Qualitätscharakteristika
Wartbarkeit und Sicherheit
gesetzt.
\end{abstract}

\section{Einleitung}

Die meisten Menschen arbeiten jeden Tag mit verschiedener Software.
In der Arbeit mit Office-Software oder je nach Beruf spezialisierter
Software für bestimmte Aufgaben und/oder Maschinen.
Zu Hause nutzen viele Menschen Unterhaltungssoftware wie Spiele,
oder Videoplattformen.
Software ist heutzutage allgegenwärtig und die meisten Menschen,
werden auch schon einmal Software schlechter Qualität genutzt haben.
Das kann durch abruptes Schließen einer Applikation,
unintuitives Design oder langer Ladezeiten
für den Nutzer erkennbar sein.
Es kann recht einfach sein,
schlechte Qualitäten in Software zu erkennen,
allerdings lässt sich Softwarequalität so nicht Objektiv vergleichen.
Diese Arbeit beschäftigt sich damit Metriken zu finden,
mit denen Software Qualität Objektiv gemessen werden kann.

\section{Softwarequalität}

Um Softwarequalität messen zu können muss zuerst festgelegt werden,
was Softwarequalität überhaupt ist.
Viele Aspekte von Softwarequalität sind für den Endnutzer gar nicht
erkennbar oder sind nur dann erkennbar,
wenn dieser Aspekt eine schlechte Qualität hat.

In dieser Arbeit wird die Definition von Softwarequalität
nach \ac{iso} 25010~\cite{ISO25010} verwendet.
In dem \ac{iso} 25010 Standard wird ein Produktqualitätsmodell
für System und Softwarequalität.
Nach diesem Modell wird die Qualität eines Softwaresystems oder Produkts
durch acht Charakteristika definiert.
Diese Charakteristika werden in Abbildung~\ref*{fig:uml:softwarequality} dargestellt.

\begin{figure}
  \centering
  \begin{plantuml}
    @startmindmap
    + ISO 25010 \nQualitätsstandard
    -- Funktionale Eignung
    -- Leistungsfähigkeit
    -- Kompatibilität
    -- Benutzerfreundlichkeit
    ++ Zuverlässigkeit
    ++ Sicherheit
    ++ Wartbarkeit
    ++ Portabilität
    @endmindmap
  \end{plantuml}
  \caption{Softwarequalität nach \ac{iso} 25010~\cite{ISO25010}}
  \label{fig:uml:softwarequality}
\end{figure}

Jedes dieser Charakteristika wird weiter in Subcharakteristika aufgeteilt.
In dieser Arbeit wird der Fokus auf zwei bestimmte Charakteristika gesetzt
und für jedes eine Metrik vorgestellt,
mit der die Qualität der Charakteristik gemessen werden kann.

Eine einzelne Metrik für Softwarequalität zu erstellen ist schwer,
da die Softwarequalität durch so viele Charakteristika beeinflusst wird.
Außerdem würde eine einzelne Metrik für die Softwarequalität nur bedingt nützlich sein.
Es wäre zwar möglich die generelle Qualität einer Software zu quantifizieren,
allerdings lässt sich dann nicht herausfinden, 
in welchen Bereichen Mängel an der Qualität der Software vorliegen.
Es ist sinnvoller einzelne Metriken für die Qualitätscharakteristika
zu erstellen, wie es auch in dieser Arbeit gemacht wird,
da so die Ursache für potenzielle Qualitätsmängel
einfacher gefunden werden kann.

% TODO hier könnten noch die einzelnen Aspekte der Softwarequalität besser beschrieben werden.

\subsection{Wartbarkeit}

Der Grad der Wartbarkeit ist nach \ac{iso},
wie effektiv und effizient das Produkt oder System verändert werden kann~\cite{ISO25010}.
Diese Veränderungen können Korrekturen, Verbesserungen
oder Anpassungen der Software auf Änderungen des Einsatzgebiets
oder auf Änderungen der Anforderungen sein~\cite{ISO25010}.
Die Wartbarkeit bezieht sich auch auf die Installation von Updates~\cite{ISO25010}.
Die Wartbarkeit ist nach \ac{iso} in weitere Subcharakteristika aufgeteilt.
Diese Subcharakteristika sind in Abbildung~\ref{fig:uml:maintainability} dargestellt.

Die Wartbarkeit ist eine der wichtigsten Qualitätscharakteristika für Entwickler.
Viele andere Qualitätscharakteristika wie 
die Benutzerfreundlichkeit oder die Leistungsfähigkeit
bewerten äußere Eigenschaften,
die für den Entwicklungsprozess nicht generell eine Rolle spielen.
So ist die Leistungsfähigkeit von Software 
meist nur in kritischen Bereichen der Software relevant.
Die Benutzerfreundlichkeit von Software spielt 
in der Regel nur in Bereichen, mit denen ein Benutzer interagiert eine Rolle.
Dagegen ist die Wartbarkeit von Software
immer dann relevant, 
wenn an und mit bestehendem Quellcode gearbeitet werden muss.
Softwareprodukte oder Systeme,
die eine hohe Wartbarkeit aufweisen,
werden in der Entwicklung und der Wartung einfacher sein
als Softwareprodukte oder Systeme,
die eine geringe Wartbarkeit aufweisen.
Außerdem muss während des ganzen Entwicklungsprozess
darauf geachtet werden die potenziell geltenden 
Regeln und Vorschriften zur Wartbarkeit von Software einzuhalten.

\begin{figure}
  \centering
  \begin{plantuml}
    @startmindmap
    + ISO 25010\nQualitätsstandard
    ++ Wartbarkeit
    +++_ Modularität
    +++_ Wiederverwendbarkeit
    +++_ Analysierbarkeit
    +++_ Modifizierbarkeit
    +++_ Testbarkeit
    @endmindmap
  \end{plantuml}
  \caption{Wartbarkeit nach \ac{iso} 25010~\cite{ISO25010}}
  \label{fig:uml:maintainability}
\end{figure}

\subsubsection{Modularität}

Die Modularität wird daran gemessen,
inwieweit das System oder Programm aus einzelnen Teilen besteht
und Änderungen an einem Teil der Software andere Teile nur minimal oder gar nicht beeinflussen~\cite{ISO25010}.
Module sind Softwareattribute, die Software in unabhängige Einzelteile trennen~\cite{IEEE24765}.

\subsubsection{Wiederverwendbarkeit}

Die Wiederverwendbarkeit ist der Grad,
zu dem ein Teil des Systems in mehr als einem System
oder beim Erstellen von weiteren Teilen des Systems verwendet werden kann~\cite{ISO25010}.
Die Wiederverwendung bezieht sich dabei nicht nur auf Software,
sondern auch auf Dokumentation, Software-Design, Applikationstests und weitere Teile des Systems~\cite{IEEE1517}.

\subsubsection{Analysierbarkeit}

Wie effektiv und effizient es möglich ist,
den Einfluss auf ein Produkt oder System abzuschätzen,
wenn ein oder mehrere Teile verändert werden,
ist durch die Analysierbarkeit definiert~\cite{ISO25010}.
Außerdem wie gut der Ursprung von Fehlern
im Produkt oder System diagnostiziert werden kann~\cite{ISO25010}.

\subsubsection{Modifizierbarkeit}

Die Modifizierbarkeit ist ein Maßstab dafür wie effektiv und effizient sich ein Produkt oder System
ändern lässt, ohne dabei Defekte einzuführen oder die Produktqualität zu verschlechtern~\cite{ISO25010}.

Die Modifizierbarkeit kann durch die \emph{Modularität} und die \emph{Analysierbarkeit} beeinflusst werden~\cite{ISO25010}.

\subsubsection{Testbarkeit}

Der Grad der Testbarkeit ist,
wie effektiv und effizient Testkriterien für ein Produkt oder System definiert werden können
und wie effektiv und effizient Tests für das Produkt oder System durchgeführt werden können~\cite{ISO25010}.
Zusätzlich zur Erstellung der Testkriterien und der Durchführung der Tests,
spielt es auch eine Rolle wie gut objektive und messbare Tests erstellt werden können,
die feststellen, ob ein bestimmtes Kriterium erfüllt wurde~\cite{IEEE24765}.

\subsection{Sicherheit}

Sicherheit beschreibt nach \ac{iso}, wie gut ein Produkt oder ein System die Informationen und Daten schützt.
Ziel ist es sicherzustellen, dass Personen und andere Systeme nur den Grad an Zugriff auf die Daten haben, für den sie berechtigt sind~\cite{ISO25010}.
Dies bezieht sich sowohl auf die Daten, die vom System gespeichert werden, als auch auf die Daten, die vom System übertragen werden~\cite{ISO25010}.
Sicherheit ist ein wichtiges Qualitätsmerkmal für Software und verbessert das Vertrauen der Benutzer und der Stakeholder in die Software~\cite{ISO25010}.
Die Sicherheit ist nach \ac{iso} in weitere Subcharakteristika aufgeteilt.
Diese Subcharakteristika sind in Abbildung~\ref{fig:uml:security} dargestellt.

Ähnlich zur Wartbarkeit ist auch Sicherheit ein sehr wichtiges Qualitätscharakteristika.
Sicherheit wird jedoch nur dann bemerkt wird, wenn sie abwesend ist und 
die Folgen fehlender Sicherheit zeigen sich meist erst einige Zeit nach der Entwicklungsphase.
Daher hat die Sicherheit der Software für viele Entwickler eher eine geringere Priorität 
und die Erfahrung mit dem Themenbereich ist eher gering~\cite{Roshaidie_Liang_Jun_Yew_Fatima-Tuz-Zahra_2020}~\cite{Tahaei_Jenkins_Vaniea_Wolters_2021}.
Trotz einem starken Anstieg an Hackerattacken (insbesondre durch den Einsatz von Ransomware) 
in den letzten Jahren~\cite{BSI_2022}~\cite{Statistik_Cybersecurity_2022} ist Sicherheit weiterhin kein festes Kriterium 
in der Design- und Entwicklungsphase vieler Teams.
Stattdessen wird die Sicherheit meist kurz vor dem Ende der Entwicklung bedacht~\cite{Roshaidie_Liang_Jun_Yew_Fatima-Tuz-Zahra_2020}, 
was die Möglichkeit zum Beheben von architekturellen oder groben Entwicklungsfehlern sehr schwer macht.
Um die Qualität der Sicherheit einer Software zu erhöhen, muss sie schon vor der eigentlichen Entwicklung, 
in der Designphase, mit bedacht werden. Ähnlich zur Wartbarkeit gilt es Regeln und Vorschriften zu definieren, 
die über die Entwicklung hinweg eingehalten werden.

\begin{figure}
  \centering
  \begin{plantuml}
    @startmindmap
    + ISO 25010\nQualitätsstandard
    ++ Sicherheit
    +++_ Vertraulichkeit
    +++_ Integrität
    +++_ Unbestreitbarkeit
    +++_ Verantwortlichkeit
    +++_ Authentizität
    @endmindmap
  \end{plantuml}
  \caption{Sicherheit nach \ac{iso} 25010~\cite{ISO25010}}
  \label{fig:uml:security}
\end{figure}

\subsubsection{Vertraulichkeit}

Vertraulichkeit misst, wie gut das System sicherstellen kann, 
dass ein Zugriff auf Daten nur von berechtigten Benutzern durchgeführt werden kann~\cite{ISO25010}.

\subsubsection{Integrität}

Die Integrität eines Systems beschreibt wie gut es den unauthorisierten Zugriff 
oder die Modifikation auf seine Programme oder Daten verhindern kann~\cite{ISO25010}.

\subsubsection{Unbestreitbarkeit}

Der Grad der Unbestreitbarkeit beschreibt, wie gut ein System beweisen kann, 
dass eine Aktion oder ein Ereignis stattgefunden hat.
So soll es einer Entität nicht möglich sein, dies zu bestreiten~\cite{ISO25010}.

Nach der \ac{iso} gibt es zwei Möglichkeit dies zu erreichen.
Der Ursprungsnachweis ist die erste Möglichkeit. 
Hier erhällt das System (der Empfänger) einen Nachweis, wer die Aktion oder das Ereignis ausgelöst hat.
Dies verhindert, dass eine Entität bestreiten kann, dass sie die Aktion oder das Ereignis ausgelöst hat~\cite{ISO7498-2}.
Die zweite Möglichkeit ist der Zustellnachweis.
Hier erhält die Entität, die die Aktion oder das Ereignis ausgelöst hat, 
einen Nachweis, dass das System (der Empfänger) die Aktion oder das Ereignis durchgeführt hat.
Dies verhindert, dass das System bestreiten kann, dass es die Anweisungen erhalten hat~\cite{ISO7498-2}.
Beide Möglchkeiten können einzeln eingesetzt werden oder auch kombiniert werden.

\subsubsection{Verantwortlichkeit}

Verantwortlichkeit gibt an wie gut die Aktionen einer Entität (z.B. Person, System) auf dieses zurückgeführt werden können~\cite{ISO25010}.
Die Verantwortlichkeit kann durch die \emph{Unnachgibigkeit} und die \emph{Integrität} des Systems beeinflusst werden. 

\subsubsection{Authentizität}
Der Grad der Gewissheit, mit dem die Identität einer Entität (z.B. Person, System) 
bewiesen werden kann wird durch die Authentizität definiert~\cite{ISO25010}.
Das Ziel ist es mit Sicherheit nachweisen zu können, das eine Entität auch die ist, die sie angibt zu sein~\cite{ISO27000}.

\section{Software Metriken}

Software Metriken sind quantitative Maße,
die zur Bewertung von Softwareprodukten und Softwaresystemen
genutzt werden können.
Diese Metriken können verschiedene Aspekte der Software Bewerten.
Hier werden Metriken vorgestellt,
mit denen die Wartbarkeit und die Sicherheit
analysiert werden könne.

Software Metriken geben sowohl den Entwicklern
als auch den Stakeholdern der Software
Informationen über Eigenschaften der Software.
Diese Informationen können nützlich sein,
um Risiken frühzeitig zu erkennen,
Verbesserungen und Verschlechterungen zu quantifizieren
und verschiedene Software vergleichen zu können.
Software Metriken können in der Kommunikation
zwischen Entwicklern und Stakeholdern helfen,
da sie helfen Eigenschaften der Software zu objektifizierten
und sich so beispielsweise bestimmte Entwicklungstätigkeiten,
wie das Refactoring von Software
besser gegenüber den Stakeholdern rechtfertigen lassen.

Mit Softwaremetriken die,
die Softwarequalität quantifizieren
können Regeln eingeführt werden,
die bestimmte Mindestanforderungen an die Softwarequalität stellen.
So kann in der Theorie eine konstante objektiv gute Qualität der Software
gewährleistet werden.
Um diese Regeln umzusetzen ist es hilfreich
die nötigen Metriken automatisch zu generieren
und Änderungen an der Software nur dann zu erlauben,
wenn die Regeln eingehalten werden.

% * Was sind Software Metriken
% * Wofür sind Software Metriken nützlich
%     * Software Vergleichen
%     * Probleme Aufzeigen
% * Software Metriken integriert in CI/CD (test coverage)
% * Software Metriken können helfen die Chefs zu überzeugen mehr in die Entwicklung zu Investieren
% TODO mehr Recherche Was Software Metriken Nützen.

\subsection{Wartbarkeit}

Viele Charakteristika der Wartbarkeit lassen sich über die Dauer oder Effizienz von Wartungsaufgaben messen.
Es kann beispielsweise die Zeit gemessen werden, die benötigt wird,
um eine Änderung an der Software durchzuführen,
um damit die Modifizierbarkeit zu charakterisieren~\cite{maintainability_metrics}.%II C 

Diese Metriken lassen sich allerdings nur bei konkreten Wartungsaufgaben messen.
Das ist problematisch, da so die Qualität der Software nur durch großen Aufwand bestimmt werden kann.
Ziel hier ist es daher eine Metrik zu finden, mit der sich die Wartbarkeit ohne großen Aufwand bestimmen lässt.
Das Paper \emph{A Practical Model for Measuring Maintainability} von Ilja Heitlager, Tobias Kuipers und Joost Visser~\cite{maintainability_metrics}
stellt eine Möglichkeit dar, die Wartbarkeit ohne großen Aufwand zu messen.
Allerdings basiert diese Paper auf dem älteren \ac{iso} 9126 Qualitätsmodell~\cite{maintainability_metrics,ISO9126}.
In dieser Arbeit wird die Metrik, die in~\cite{maintainability_metrics} daher erweitert
und auf das neuere \ac{iso} 25010 Qualitätsmodell angepasst.

Für diese Metrik werden einige einfache Kennzahlen der Software kombiniert,
um Kennwerte für die Jeweiligen Subcharakteristika der Wartbarkeit zu berechnen.
Diese Kennwerte können dann verwendet werden, um einen Gesamtwert
für die Wartbarkeit der Software zu bekommen.
Die Kennzahlen die Genutzt werden sind.

\paragraph{Quellcodevolumen}

Die Zahl der effektiven Quellcodezeilen im gesamten Bereich der analysiert werden soll.
Je geringer das Quellcodevolumen ist,
desto einfacher ist es eine Übersicht über den Bereich zu bekommen,
der analysiert werden soll.
Also ist niedriger besser.

\paragraph{Komplexität der Einheiten}

Die zyklomatische Komplexität einer Einheit sagt aus wie Komplex eine Einheit ist,
und damit auch wie komplex Wartungsaufgaben sein können.
Eine Einheit ist dabei das kleinste ausführbare Stück Code~\cite{maintainability_metrics}.
Je nach Programmiersprache kann eine Einheit eine Funktion, eine Klasse oder aber das gesamte Programm sein~\cite{maintainability_metrics}.
Eine geringere Komplexität spricht für besser wartbare Software.
Die zyklomatische Komplexität von Software kann mit Tools
wie \emph{scc}~\cite{scc} automatisiert gemessen werden.
Hier ist also niedriger besser.

\paragraph{Quellcode Duplikation}

Quellcode Duplikation ist definiert durch die Anzahl Quellcode Zeilen,
die eins zu eins an verschiedenen Stellen zu finden sind.
Duplikation spricht für Probleme in der Software.
Also ist für eine höhere Qualität der Software eine niedrige Duplikation besser.

\paragraph{Einheitengröße}

Eine geringe Einheitengröße sorgt für eine höhere Softwarequalität,
da kleinere Einheiten einfacher zu warten sind.

\paragraph{Unit-Testabdeckung}

Die Testabdeckung durch Unit-Tests wird häufig verwendet,
um Aussagen über die Softwarequalität zu machen.
Hier wird diese Metrik auch verwendet.
Allgemein gilt, je mehr Unit-Tests vorhanden sind, desto besser.

\paragraph{Modulanzahl}

Die Modulanzahl gibt Aussage über die Modularisierung von Software.
Je höher die Modulanzahl, desto modularisierter ist die Software.
Hier ist also höher besser.

\paragraph{Wiederverwendung von Einheiten}

Die Wiederverwendung von Einheiten sagt aus,
wie oft eine Einheit an anderer Stelle im Quellcode wiederverwendet wird.
Das kann gemessen werde, indem gezählt wird wie oft Klassen genutzt werden
oder wie oft Funktionen aufgerufen werden.
Hier gilt, höher ist besser.

Diese Kennzahlen werden wie folgt kombiniert,
um Metriken für die Subcharakteristika zu erhalten.

\paragraph{Modularität}

Eine einfache Metrik für die Modularität ist die Modulanzahl
in dem betrachteten Teil der Software.
Nachteil dieser Metrik ist, dass sie nicht aussagt,
inwieweit Änderungen an einem Modul die anderen Module beeinflussen.
Nach ISO 25010 sollen Änderungen an einem Modul,
die anderen Module möglichst wenig beeinflussen~\cite{ISO25010}.

Eine andere Metrik ist die Einheitengröße.
Diese gibt auch eine gewisse objektive Aussage über die Modularität.
Für eine hohe Modularität ist eine geringe Kopplung und
hohe Kohäsion, also hohe Zusammengehörigkeit, innerhalb der Einheiten nötig um zu gewährleisten,
dass Änderungen an einem Modul, die anderen Module minimal oder gar nicht beeinflussen.
Viele kleine Einheiten sprechen für eine hohe Kohäsion,
da in einer kleinen Einheit nur wenig Funktionalität,
die dann aber stark zusammenhängt, implementiert werden kann.

Sowohl die Modulanzahl als auch die Einheitengröße werden
für die Modularität-Metrik verwendet.

\paragraph{Wiederverwendbarkeit}

Die Wiederverwendbarkeit lässt sich nicht direkt messen,
allerdings kann gemessen werden wie oft Softwarekomponenten
tatsächlich wiederverwendet werden, also die Wiederverwendung.
Bei hoher Wiederverwendung muss auch die Wiederverwendbarkeit hoch sein.
Eine niedrige Wiederverwendung ist ein starker Indikator für niedrige Wiederverwendbarkeit.

Eine weitere Metrik für die Wiederverwendung ist die Code-Duplikation und die Einheitengröße.
Wenn hohe Code-Duplikation vorhanden ist, ist die Wiederverwendung in der Regel gering,
da duplizierter Code oft wiederverwendbarer implementiert werden kann.
Bei geringer Code-Duplikation kann davon ausgegangen werden,
dass eine hohe Wiederverwendung des Codes gegeben ist.
Für eine hohe Wiederverwendbarkeit ist es wichtig,
dass Einheiten nur wenige Aufgaben haben.
Eine geringe Einheitengröße deutet daher auf eine höhere Wiederverwendbarkeit.

\paragraph{Analysierbarkeit}

Nach~\cite{maintainability_metrics} werden Code-Volumen, Code-Duplikation, Einheitengröße
und Unit-Testabdeckung verwendet, um die Analysierbarkeit zu quantifizieren.
Geringes Code-Volumen und geringe Einheitengröße hilft
schnell einen Überblick über den Quellcode zu bekommen.
Unit-Tests helfen die Funktionsweise des Quellcodes zu verstehen.
Eine hohe Quellcode-Duplikation erschwert hingegen das Verständnis.
% TODO einfluss der einzelnen auf die Analysierbarkeit

\paragraph{Modifizierbarkeit}

In~\cite{maintainability_metrics} wird die Komplexität der Einheiten und die Code-Duplikation
als Metrik für die Modifizierbarkeit genannt.
Code-Duplikation verringert die Modifizierbarkeit, da an Stellen mit dupliziertem Code,
alle Teile des duplizierten Codes gleichermaßen geändert werden müssen.
Das erhöht den Modifikations-Aufwand stark und erhöht die Chance,
dass bei Modifikationen vergessen wird Teile des duplizierten Codes zu ändern und so Fehler im Programm entstehen.
Eine hohe Komplexität der Einheiten sorgt dafür,
dass es schwieriger ist diese Einheiten zu modifizieren, ohne Fehler in der Software zu erzeugen.

\paragraph{Testbarkeit}

Die Testbarkeit von Software hängt nach~\cite{maintainability_metrics} unter anderem von der Komplexität der Einheiten,
der Einheitengröße und der Zahl der Unit-Testabdeckung ab.
Eine hohe Unit-Testabdeckung ist ein Indikator für gute Testbarkeit,
denn das bedeutet, dass die Software im allgemeinen testbar ist.
Kleine Einheitengröße sorgt auch für eine bessere Testbarkeit,
da es einfacher ist für kleine Einheiten, die weniger Aufgaben haben, Testfälle zu spezifizieren.
Die Komplexität der Einheiten spielt auch eine Rolle,
da für komplexe Einheiten voraussichtlich mehr und komplexere Testfälle spezifiziert werden müssen.

\begin{center}
  \begin{table}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{NiceTabular}{|l|c|c|c|c|c|c|c|}
      \hline
      & \rotate Quellcodevolumen
      & \rotate Komplexität der Einheiten
      & \rotate Quellcode Duplikation
      & \rotate Einheitengröße
      & \rotate Unit-Testabdeckung
      & \rotate Modulanzahl
      & \rotate Wiederverwendung von Einheiten \\\hline
      Modularität           & & & &x& &x& \\\hline
      Wiederverwendbarkeit  & & &x&x& & &x\\\hline
      Analysierbarkeit      &x& &x&x&x& & \\\hline
      Modifizierbarkeit     & &x&x& & & & \\\hline
      Testbarkeit           & &x& &x&x& & \\\hline
    \end{NiceTabular}
    \caption{Zugehörigkeit der Kennzahlen zu den Wartbarkeit-Subcharakteristika}
    \label{table:maintainability_metrics}
  \end{table}
\end{center}

In Tabelle~\ref{table:maintainability_metrics} wird die Zugehörigkeit
der zuvor vorgestellten Quellcode Kennzahlen zu den
Wartbarkeit-Subcharakteristika dargestellt.
Diese Tabelle erweitert die in~\cite{maintainability_metrics}
vorgestellte Tabelle um die Änderungen die der neuere \ac{iso} 25010 Qualitätsstandard
gegenüber dem alten \ac{iso} 9126 Standard bringt.
Damit kann nun Software verglichen werden und Qualitätsänderungen
durch Änderungen an der Software gemessen werden.
Im Gegensatz zu~\cite{maintainability_metrics}
wird hier keine konkrete Kennzahl für die Wartbarkeit vorgestellt.
Vielmehr können mit dieser Metrik Softwarestände und Softwaresysteme relativ zueinander verglichen werden.
Dafür werden die relativen Unterschiede in den einzelnen Metriken eins zu eins nach der Tabelle verrechnet,
um einen Wert für die Jeweilige Subcharakterstik der Wartbarkeit zu erhalten.
Um daraus einen Wert für die Wartbarkeit zu erhalten,
werden die Werte der Subcharakteristika eins zu eins verrechnet.

Um diese Metrik zu verbessern,
kann die Verrechnung der einzelnen Quellcode-Kennzahlen
gewichtet werden.
Diese Entscheidung kann je nach Anwendung der Metrik getroffen werden.

Es ist denkbar diese Metrik automatisch durch
Softwaretools zu generieren.
Das ermöglicht es diese Metrik, als Auswertung von Software
in ein \ac{cicd} System zu integrieren.
Damit können Änderungen an der Software ausgewertet werden
und gewarnt werden, wenn die Wartbarkeit durch Änderungen an der Software verschlechtert wird.
Im extremsten Fall, kann eine Änderung auch abgelehnt werden, wenn die Wartbarkeit verschlechtert wird.

\subsection{Sicherheit}

Sicherheit ist ein Feld, welches in der Informatik sehr weit gefasst ist und in den meisten Themenbereichen eine elementare Rolle spielt.
Daher ist es nicht verwunderlich, dass es schwer ist allgemeine Metriken für das Messen der Sicherheit von Software zu erarbeiten.
Es gibt einige Artikel und Konferenz Papiere, die unterschiedliche Ansätze für das definieren von Metriken verfolgen und es gibt einige 
Metaanalysen, die die Ergebnisse dieser Arbeiten miteinander vergleichen. 
Zusätzlich dazu wurden Standards definiert, welche jedoch weit gefasst sind und eine unpräzise Definition für Sicherheits-Metriken liefern~\cite{MeFlado_Fernández-Medina_Piattini_2010}.

Um einen konkreten Ansatz für die Bewertung der Sicherheit mittels Metriken zu finden werden 
drei unterschiedliche Ansätze (vereinfacht) vorgestellt~\cite{Jain2014SecurityMA}~\cite{Chowdhury_Chan_Zulkernine_2008}~\cite{Wang_Wang_Guo_Xia_2009} und miteinander Kombiniert.
Ziel ist es so eine Sammlung an Metriken zu erhalten, 
welche eine Bewertung der Sicherheit einer Software über den Entwicklungsprozess hinweg ermöglichen. 
Abschließend wird bewertet, inwieweit die Sammlung der Metriken alle Subcharakteristika für Sicherheit im \ac{iso} 25010 Qualitätsmodell abdeckt.

\subsubsection{Security Metrics and Software Development Progression~\cite{Jain2014SecurityMA}}

In ihrem Artikel Security Metrics and Software Development Progression beschreiben die Autoren Smirity Jain und Maya Ingle eine Sammlung von Metriken, 
welche die Sicherheit von Software über den gesamten Entwicklungsprozesses hinweg messen.
Mit diesen Metriken ist es möglich im nachhinein die Effektivität der fünf Phasen des Entwicklungsprozesses in Hinblick auf die Sicherheit zu messen.
Im folgenden wird eine Auswahl der wichtigsten Metriken für die Phasen vorgestellt.

\paragraph{Phase 1: Anforderungsanalyse}

Diese Phase konzentriert sich auf das Sammeln von (Sicherheits-) Anforderungen.
Smirity und Ingle beschreiben hier vier Metriken für die Sicherheit.
\begin{itemize}
  \item \textbf{Number of Security Requirements Gathered (NSRG)}: Anzahl der Sicherheitsanforderungen die in dieser Phase erfasst wurden.
  \item \textbf{Security Requirements Recorded Deviations (SRRD)}: Anzahl der Abweichungen von den zuvor definierten Sicherheitsanforderungen in den Anforderungsspezifikationen.
  \item \textbf{Security Requirements stage Security Errors (SRSE)}: Anzahl der Sicherheitsfehler, welche aus fehlerhaften Sicherheitsanforderungen resultieren.
  \item \textbf{Security Requirements Gathering Indicators (SRI)}: Misst den Einfluss der Analysephase auf die Anzahl der Sicherheitslücken. 
\end{itemize}
Für die Auswertung dieser Metriken schlagen die Autoren vor, dass diese Metriken mit der Methode der kleinsten Quadrate zusammengefasst werden.
Dabei werden die Metriken SRRD, SRSE und SRI als abhängig definiert, während NSRG als unabhängig betrachtet wird.
Das Resultat dieser Rechnung ist die Funktion \alpha, welche die Effektivität dieser Phase in Bezug auf die Sicherheit misst.
Alpha wird mit der Formel \ref{eq:alpha} berechnet, wobei Y die Summe der Werte der Metriken SRRD, SRSE und SRI ist.
\alpha ist im Interval von -1 bis 1 Aussagekräftig, ein größerer Wert bedeutet eine bessere Effektivität.
Ein wert von -1 bedeutet das Sicherheit in der Phase nicht berücksichtigt wurde 
und ein Wert größer als 1 bedeutet das die Effektivität nicht bewertet werden kann.
\begin{equation} \label{eq:alpha}
  \alpha = \frac{ \left( 5,2421 - Y \right) }{ NSRG }
\end{equation}

\paragraph{Phase 2: Design}

In dieser Phase werden die Anforderungen in ein Design überführt. 
Hier ist die Umsetzung von nicht-funktionalen Anforderungen, wie Fehlerbehandlung, Fehlermeldungen und Autorisierung wichtig.
Die Autoren definieren für diese Phase drei Metriken.
\begin{itemize}
  \item \textbf{Security Requirements Statistics (SRs)}: Prozentsatz der Sicherheitsanforderungen, welche in der Designphase bedacht wurden.
  \item \textbf{Design Tools und Test Effectiveness (DTTE)}: Misst den Anteil von Analysetools (z.B. Threat Analysis und Attack Patterns) und Testing an den Sicherheitsrelevanten Designaspekten. 
  \item \textbf{Number of Design stage Security Errors (NDSE)}: Misst die Anzahl der Sicherheitsfehler, welche aus dem Softwaredesign resultieren. 
\end{itemize}
Für die Auswertung dieser Metriken multipizieren die Autoren die Metriken DTTE und NDSE, das Ergebnis ist \beta. 
Da DTTE den Anzeil von Tools und Tests an dem resultierenden Design misst und NSDE die Fehler welche aus dieser Phase entstehen zählt, 
beschreibt \beta die Effektivität der Designphase in Bezug auf die Sicherheit.
\beta wird mit der Formel \ref{eq:beta} berechnet und ist immer größer gleich 0. 
Der \beta-Wert sollte zwischen 0 und 1 liegen, ein größerer Wert bedeutet eine schlechtere Effektivität.
Ein \beta-Wert von 0 impliziert, dass das Testing sehr Effektiv ist und es keine Fehler in der Designphase gibt.
\begin{equation} \label{eq:beta}
  \beta = NDSE * DTTE
\end{equation}

\paragraph{Phase 3: Implementierung}

In dieser Phase wird Sicherheit durch Input- und Outputvalidierung und durch die Verwendung von guten Programmierstandards erreicht.
Die Autoren beschreiben hier drei Metriken um die Sicherheitsanstrengungen der Entwickler zu messen.
\begin{itemize}
  \item \textbf{Percent of Secure Coding Aspects (PSCA)}: Misst das Verhälltnis der Sicherheitsrelevanten Coding-Aspekte in der Entwicklungsphase im Vergleich zu den Designaspekten (aus der Designphase).
  \item \textbf{Percent use of Coding Standards (PCS)}: Misst den Anteil an Coding-Standards für sichere Entwicklung, die verwendet wurden. Sie kann als ein Annährung für NSE dienen.
  \item \textbf{Number of Security Errors (NSE)}: Misst die Anzahl an Programmierfehlern, welche im Programm vorhanden sind oder durch externe Librarys eingebracht wurden.
\end{itemize}
Für die Auswertung verwenden die Autoren wird hier wieder die Methode der kleinsten Quadrate verwendet.
Der resultierende Wert \gamma (\ref{eq:gamma}) beschreibt die Effektivität der Implementierungsphase in Bezug auf die Sicherheit.
Ein negativer \gamma Wert deutet auf eine hohe Fehleranzahl hin und ein Wert nahe 0 deutet auf eine gute Effektivität der Phase hin.
\begin{equation} \label{eq:gamma}
  \gamma = \frac{ 8,4022 - NSE }{ PSCA + PCS }
\end{equation}

\paragraph{Phase 4: Testen}

In dieser Phase wird die Software auf Sicherheitslücken getestet.
Die wichtigsten Metriken sind folgende.
\begin{itemize}
  \item \textbf{Process Effectiveness (PE)}: Beschreibt das Verhältnis zwischen der Anzahl der entdeckten Sicherheitslücken und der Anzahl der Module, die Sicherheitstest unterzogen wurden.
  \item \textbf{Security Testing Ratio (STR)}: Misst den Anteil der Module, die Sicherheitstests unterzogen wurden.
\end{itemize}

\paragraph{Phase 5: Betrieb und Wartung}

In dieser Phase werden Risikobewertungen und Sicherheitsanalysen durchgeführt um bei Patches eingebrachte Sicherheitsfehler zu finden.
Außerdem findet hier das Logging, Monitoring und die Analyse von Sicherheitsereignissen statt.
Die Autoren beschreiben hier X Metriken.
\begin{itemize}
  \item \textbf{Mean Time to Complete Security Changes (MTCSC)}: Schätzt die durchschnittliche Zeit, die es braucht um einen Sicherheitsfehler zu beheben. 
  \item \textbf{Rate of Vulnerability Assessments (RVA)}: Misst die Anzahl der Sicherheitsanalysen pro Quartal.
  \item \textbf{Ratio of Changes due to security considerations (RSC)}: Misst den Anteil der Änderungen am System auf Grund neuer Sicherheitsanforderungen im Vergleich zur gesammtheit der Systemänderungen.
\end{itemize}

\subsubsection{Security Metrics for Source Code Structures~\cite{Chowdhury_Chan_Zulkernine_2008}}

# Hier weiter

\subsubsection{Security Metrics for Software Systems~\cite{Wang_Wang_Guo_Xia_2009}}

\subsubsection{Kombination der Ansätze und Bewertung der Metriken}


\section{Ausblick}

% TODO kritische Auseinandersetzung mit dieser Metrik.
Die hier vorgestellte Metrik zur Wartbarkeit macht es zwar einfach
die Wartbarkeit von Softwareprodukten und Softwaresystemen
zu messen, allerdings hat diese Metrik auch einige Nachteile.
So kann diese Metrik keine direkte Aussage über die Dauer 
von Wartungsaufgaben an der Software machen.
Außerdem wurde nicht verglichen wie sich diese Metrik 
im Vergleich mit anderen Wartbarkeit-Metriken verhält.
Es ist denkbar, dass die hier vorgestellte Metrik
völlig andere Werte als andere Wartbarkeit-Metriken liefert.
In einer weiteren Arbeit könnte darauf eingegangen werden
und die hier vorgestellte Wartbarkeit-Metrik
mit andere Wartbarkeit-Metriken verglichen werden,
um festzustellen, inwieweit sich diese unterscheiden.

Außerdem bietet die hier vorgestellte Wartbarkeit-Metrik 
die Möglichkeit Gewichte zu setzen, 
um die Metrik weiter zu verbessern und anzupassen.
In einer weiteren Arbeit könnte diese Metrik durch
die Gewichtungen an andere Wartbarkeit-Metriken angepasst werden.

In einer weiteren Arbeit ist es außerdem Denkbar weitere Metriken zu finden,
mit denen die übrigen Qualitätscharakteristika 
einfach quantifiziert werden können.


% * Welche Punkte wurden in der Arbeit abgehandelt
% * Welche stellen fehlen in dieser Arbeit Noch
%   * Die anderen Qualitätscharakteristika
%   * Weitere Metriken für die Gewählten Charakteristika

\newpage
\printbibliography

\end{document}
